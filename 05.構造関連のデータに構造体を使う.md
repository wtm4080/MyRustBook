# 構造関連のデータに構造体を使う

* _struct_ または構造体は、あなたに名前を付けさせて、意味を持つグループを構成する関連する複数の値をパッケージにさせるカスタムデータ型だ
* もしオブジェクト指向言語になじみがあるなら、_struct_ はオブジェクトのデータ属性のようなものだ
* この章では、タプルを構造体と比較・対照して、_struct_ の使い方をデモし、_struct_ に関連付けられた振る舞いを指定するための _method_ や _associated function_ の使い方を議論する
* _struct_ や _enum_ (6 章で議論する) は、Rust のコンパイル時型チェックの利点をフルに享受するために、あなたのプログラミングのドメインにおいて新しい型を作成することに対する、Rust の構成要素だ

## _struct_ を定義して _instance_ 化する

* _struct_ は 3 章で議論したタプルに似ている
  * タプルのように、_struct_ の一部分は違った型になることができる
* しかし、タプルのようではなく、それぞれのデータ片に名前を付けることになるので、値が意味するところが明瞭だ
  * この名前付けの結果として、_struct_ はタプルよりももっと柔軟だ
  * _instance_ の値を指定したりアクセスしたりするのに、順番に頼る必要がない
* _struct_ を定義するために、キーワード `struct` を入力して、_struct_ 全体に名前を付ける
  * _struct_ の名前は、グループ化されたデータそれぞれの意義を述べるものであるべきだ
* それから、波括弧内で、_field_ と呼ばれる、データそれぞれの名前と型を定義する
* 例えば、Listing 5-1 は、ユーザーアカウントについての情報を保存する _struct_ を表している

```rust
struct User {
  username: String,
  email: String,
  sign_in_count: u64,
  active: bool,
}
```

Listing 5-1: `User` _struct_ の定義

* _struct_ を定義した後それを使うために、それぞれの _field_ に対して値の実体を指定することで、その _struct_ の _instance_ を作成する
* _struct_ の名前を述べて、それから `key: value` のペアを含んだ波括弧を加えることで _instance_ を作成する
  * `key: value` ペアのキーは _field_ の名前で、値はそれらの _field_ に保存したいデータだ
  * _struct_ の宣言と同じ順番で _field_ を指定する必要はない
* 言い換えると、_struct_ の定義は型に対する一般的なテンプレートのようなもので、_instance_ はその型の値を作るために特定のデータでテンプレートを埋めるようなことだ
* 例えば、Listing 5-2 で表されるように、特定のユーザーを宣言できる

```rust
let user1 = User {
  email: String::from("someone@example.com"),
  username: String::from("someusername123"),
  active: true,
  sign_in_count: 1,
};
```

Listing 5-2: `User` _struct_ の _instance_ の作成

* _struct_ から特定の値を得るために、ドット表記を使える
  * もし丁度ユーザーのメールアドレスが欲しいなら、この値を使いたいところならどこでも `user1.email` を使うことができる
* もし _instance_ が可変なら、ドット表記を使って特定の _field_ へと代入することで値を変更できる
* Listing 5-3 は、可変な `User` _instance_ の `email` _field_ の値をどのように変更するかを表している

```rust
let mut user1 = User {
  email: String::from("someone@example.com"),
  username: String::from("someusername123"),
  active: true,
  sign_in_count: 1,
};

user1.email = String::from("anotheremail@example.com");
```

Listing 5-3: `User` _instance_ の `email` _field_ の値を変更する

* _instance_ 全体が可変でなければならないことを覚えておこう
  * Rust は特定の _field_ だけを可変だとして印をつけることを許さない
* どの式とも同じように、暗黙的に新しい _instance_ を返すために、関数本文の最後の式としてその _struct_ の新しい _instance_ を構築できる
  * Listing 5-4 は、与えられたメールアドレスとユーザー名で `User` _instance_ を返す `build_user` 関数を表している

```rust
fn build_user(email: String, username: String) -> User {
  User {
    email: email,
    username: username,
    active: true,
    sign_in_count: 1,
  }
}
```

Listing 5-4: メールアドレスとユーザー名を取って `User` _instance_ を返す `build_user` 関数

* 関数のパラメーターを _struct_ の _field_ と同じ名前にすることは意味を成すが、`email` と `username` _field_ の名前と変数を繰り返すのは少し退屈だ
  * もし _struct_ がより多くの _field_ を持っていたら、それぞれの名前を繰り返すのはさらに煩わしいだろう
  * 幸運なことに、便利な省略表現がある！

### 変数と _field_ が同じ名前を持つときに、_field_ 初期化の省略表現を使う

* Listing 5-4 で、パラメーター名と _struct_ _field_ 名が正確に同一なので、_build_user_ を書き換えるために _field_ 初期化の省略表現を使える
  * なので、同じように振る舞うが、Listing 5-5 に示されるように、`email` と `username` の繰り返しがない

```rust
fn build_user(email: String, username: String) -> User {
  User {
    email,
    username,
    active: true,
    sign_in_count: 1,
  }
}
```

Listing 5-5: `email` と `username` が _struct_ _field_ として同じ名前を持っているので、_field_ 初期化の省略表現を使う `build_user` 関数

* ここでは、`email` と名付けられた _field_ を持つ、`User` _struct_ の新しい _instance_ を作っている
* `email` _field_ の値を _build_user_ 関数のパラメーター `email` へと設定したい
* `email` _field_ と `email` パラメーターは同じ名前を持っているので、`email: email` ではなく、単に `email` とだけ書く必要がある

### _struct_ 更新文法で他の _instance_ から _instance_ を作成する

* ほとんどの古い _instance_ の値を使うが、いくつかを変更する、新しい _struct_ の _instance_ を作成するのがしばしば便利だ
  * _struct_ 更新文法をつかうことでこれができる
* 始めに、Listing 5-6 は、更新文法なしで `user2` へと新しい `User` _instance_ をどのように作成するかを示している
  * `email` と `username` に対する新しい値を設定しているが、一方で Listing 5-2 で作成した `user1` から同じ値を使う

```rust
let user2 = User {
  email: String::from("another@example.com"),
  username: String::from("anotherusername567"),
  active: user1.active,
  sign_in_count: user1.sign_in_count,
};
```

Listing 5-6: `user1` からいくつかの値を使って新しい `User` _instance_ を作成

* _struct_ 更新文法を使って、Listing 5-7 で示されるように、より少ないコードで同じ効果を達成できる
* `..` 文法が、明示的に設定されない残りの _field_ が与えられた _instance_ の _field_ と同じ値を持つべきだと指定している

```rust
let user2 = User {
  email: String::from("another@example.com"),
  username: String::from("anotherusername567"),
  ..user1
};
```

Listing 5-7: `User` に対して新しい `email` と `username` の値を設定するが、変数 `user1` の _instance_ の _field_ から残りの値を使うために、_struct_ 更新文法を使う

* Listing 5-7 のコードもまた、`email` と `username` に対して違った値を持つが、`user1` からの `active` と `sign_in_count` に対する同じ値を持つ、`user2` _instance_ を作成する

### 異なる型を作るために、名前付けられた _field_ 無しでタプル _struct_ を使う

* タプルに似たように見える _struct_ を定義することもできる
  * タプル _struct_ と呼ばれる
* タプル _struct_ は、_struct_ の名前が提供する意味合いの追加があるが、_field_ に紐づいた名前を持たない
  * むしろ、ただ _field_ の型を持つ
* タプル全体に名前を与えて、他のタプルと違うタプルにしたい時に、タプル _struct_ は便利だ
  * そして、通常の _struct_ のようにそれぞれの _field_ に名前を付けるのが冗長になるだろう時にも便利だ
* タプル _struct_ を定義するために、`struct` キーワードと _struct_ の名前で始めて、タプル内の型が続く
  * 例えば、以下が `Color` と `Point` と名付けられた二つのタプルの定義と使い方だ

```rust
struct Color(i32, i32, i32);
struct Point(i32, i32, i32);

let black = Color(0, 0, 0);
let origin = Point(0, 0, 0);
```

* `black` と `origin` は型が違うことを覚えておこう
  * それらは違ったタプル _struct_ の _instance_ なので
  * あなたが定義したそれぞれの _struct_ はそれ自身の型であって、_struct_ 内の _field_ が同じ型を持っている場合でさえもそうだ
  * 例えば、型 `Color` のパラメーターを取る関数は `Point` を引数として取ることができない
    * 両方の型が三つの `i32` で構成されている場合でさえもそうだ
  * それ以外の場合、タプル _struct_ の _instance_ はタプルのように振る舞う
    * 個々の断片に分解できる
    * `.` とそれに続くインデックスを使って個々の値にアクセスできる
    * 等々

### どの _field_ も持たない _unit_ のような _struct_

* どの _field_ も持たない _struct_ を定義することもできる！
* これらは _unit_ のような _struct_ と呼ばれる
  * _unit_ 型 `()` と似たように振る舞うので
* 何らかの型に _trait_ を実装したいが、その型自身に保存したいデータがない場合に _unit_ のような _struct_ は便利になり得る
* 10 章で _trait_ を議論するだろう

---

### _struct_ データの所有権

* Listing 5-1 の `User` _struct_ の定義で、文字列 _slice_ 型 `&str` ではなく、所有された `String` を使った
* これはよく考えたうえでの選択だ
  * 全てのデータを所有して、そのデータが _struct_ 全体が有効である限り有効である _struct_ の _instance_ が欲しいため
* 他の何かによって所有されるデータへの _reference_ を保存する _struct_ もあり得るが、そうするためには _lifetime_ の使用が求められる
  * _lifetime_ は 10 章で議論するであろう Rust の機能だ
* _lifetime_ は、_struct_ が有効である限り、_struct_ によって参照されるデータが有効であることを確かなものにする
* 以下のように、_lifetime_ の指定なしで _struct_ に _reference_ を保存しようとするとしてみよう
  * それは動かない

ファイル名: src/main.rs

```rust
struct User {
  username: &str,
  email: &str,
  sign_in_count: u64,
  active: bool,
}

fn main() {
  let user1 = User {
    email: "someone@example.com",
    username: "someusername123",
    active: true,
    sign_in_count: 1,
  };
}
```

* コンパイラーは _lifetime_ の指定が必要だと抗議してくるだろう

```bash
error[E0106]: missing lifetime specifier
 -->
  |
2 |     username: &str,
  |               ^ expected lifetime parameter

error[E0106]: missing lifetime specifier
 -->
  |
3 |     email: &str,
  |            ^ expected lifetime parameter
```

* 10 章で、これらのエラーをどのようにして修正するかを議論し、_struct_ に _reference_ を保存できるようになるが、今のところ、`&str` のような _reference_ の代わりに、`String` のような所有される型を使ってこれらのようなエラーを修正することになるだろう

---
