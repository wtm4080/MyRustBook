# 構造関連のデータに構造体を使う

* _struct_ または構造体は、あなたに名前を付けさせて、意味を持つグループを構成する関連する複数の値をパッケージにさせるカスタムデータ型だ
* もしオブジェクト指向言語になじみがあるなら、_struct_ はオブジェクトのデータ属性のようなものだ
* この章では、タプルを構造体と比較・対照して、_struct_ の使い方をデモし、_struct_ に関連付けられた振る舞いを指定するための _method_ や _associated function_ の使い方を議論する
* _struct_ や _enum_ (6 章で議論する) は、Rust のコンパイル時型チェックの利点をフルに享受するために、あなたのプログラミングのドメインにおいて新しい型を作成することに対する、Rust の構成要素だ

## _struct_ を定義して _instance_ 化する

* _struct_ は 3 章で議論したタプルに似ている
  * タプルのように、_struct_ の一部分は違った型になることができる
* しかし、タプルのようではなく、それぞれのデータ片に名前を付けることになるので、値が意味するところが明瞭だ
  * この名前付けの結果として、_struct_ はタプルよりももっと柔軟だ
  * _instance_ の値を指定したりアクセスしたりするのに、順番に頼る必要がない
* _struct_ を定義するために、キーワード `struct` を入力して、_struct_ 全体に名前を付ける
  * _struct_ の名前は、グループ化されたデータそれぞれの意義を述べるものであるべきだ
* それから、波括弧内で、_field_ と呼ばれる、データそれぞれの名前と型を定義する
* 例えば、Listing 5-1 は、ユーザーアカウントについての情報を保存する _struct_ を表している

```rust
struct User {
  username: String,
  email: String,
  sign_in_count: u64,
  active: bool,
}
```

Listing 5-1: `User` _struct_ の定義

* _struct_ を定義した後それを使うために、それぞれの _field_ に対して値の実体を指定することで、その _struct_ の _instance_ を作成する
* _struct_ の名前を述べて、それから `key: value` のペアを含んだ波括弧を加えることで _instance_ を作成する
  * `key: value` ペアのキーは _field_ の名前で、値はそれらの _field_ に保存したいデータだ
  * _struct_ の宣言と同じ順番で _field_ を指定する必要はない
* 言い換えると、_struct_ の定義は型に対する一般的なテンプレートのようなもので、_instance_ はその型の値を作るために特定のデータでテンプレートを埋めるようなことだ
* 例えば、Listing 5-2 で表されるように、特定のユーザーを宣言できる

```rust
let user1 = User {
  email: String::from("someone@example.com"),
  username: String::from("someusername123"),
  active: true,
  sign_in_count: 1,
};
```

Listing 5-2: `User` _struct_ の _instance_ の作成

* _struct_ から特定の値を得るために、ドット表記を使える
  * もし丁度ユーザーのメールアドレスが欲しいなら、この値を使いたいところならどこでも `user1.email` を使うことができる
* もし _instance_ が可変なら、ドット表記を使って特定の _field_ へと代入することで値を変更できる
* Listing 5-3 は、可変な `User` _instance_ の `email` _field_ の値をどのように変更するかを表している

```rust
let mut user1 = User {
  email: String::from("someone@example.com"),
  username: String::from("someusername123"),
  active: true,
  sign_in_count: 1,
};

user1.email = String::from("anotheremail@example.com");
```

Listing 5-3: `User` _instance_ の `email` _field_ の値を変更する

* _instance_ 全体が可変でなければならないことを覚えておこう
  * Rust は特定の _field_ だけを可変だとして印をつけることを許さない
* どの式とも同じように、暗黙的に新しい _instance_ を返すために、関数本文の最後の式としてその _struct_ の新しい _instance_ を構築できる
  * Listing 5-4 は、与えられたメールアドレスとユーザー名で `User` _instance_ を返す `build_user` 関数を表している

```rust
fn build_user(email: String, username: String) -> User {
  User {
    email: email,
    username: username,
    active: true,
    sign_in_count: 1,
  }
}
```

Listing 5-4: メールアドレスとユーザー名を取って `User` _instance_ を返す `build_user` 関数

* 関数のパラメーターを _struct_ の _field_ と同じ名前にすることは意味を成すが、`email` と `username` _field_ の名前と変数を繰り返すのは少し退屈だ
  * もし _struct_ がより多くの _field_ を持っていたら、それぞれの名前を繰り返すのはさらに煩わしいだろう
  * 幸運なことに、便利な省略表現がある！
