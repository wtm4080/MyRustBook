# 所有権を理解する

* 所有権は Rust の最も特異な機能で、ガベージコレクター無しで Rust がメモリ安全性を保障できるようにするものだ
* したがって、Rust で所有権がどのように働くかを理解しておくことは重要だ
* この章では、所有権やいくつかの関連する機能について話していく
  * 借用
  * スライス
  * Rust のメモリーレイアウトの仕方

## 所有権とは何？

* Rust の中心的な機能は所有権だ
  * 機能を説明するのは複雑ではないが、言語の残りの部分に対する深い含蓄を持っている
* すべてのプログラムは実行時のコンピューターのメモリーの使い方を管理しなければならない
  * いくつかの言語は、プログラムの実行時にもう使われなくなったメモリーを常に見張るガベージコレクションを持っている
  * そのほかの言語では、プログラマーが明示的にメモリーの割り当てと解除を行わなければならない
  * Rust では、三つ目のアプローチをとっている
    * コンパイル時にコンパイラーがチェックする規則の組を伴った所有権システムでメモリーを管理している
    * どの所有権の機能も実行時にプログラムを遅くしない
* 多くのプログラマーにとって所有権は新しい概念なので、それに慣れるためにいくらかの時間をかける
* ここでよいニュース
  * Rust と所有権システムを経験すればするほど、安全で効率的なコードを自然に開発できるようになる。がんばって！
* 所有権を理解したとき、Rust を特異たらしめる機能を理解するための確固たる基礎を持つことになるだろう
* この章では、とっても一般的なデータ構造である文字列に焦点を当てて例に取り組むことで、所有権を学んでいくことになるだろう

---

### スタックとヒープ

* 多くの言語では、スタックとヒープについてはそれほど考える必要はない
* しかし、Rust のようなシステムプログラミング言語では、値がスタックとヒープどちらかにあるかはより効力を持っている
  * どのように言語が振る舞うか
  * なぜあなたがそのような決定を下したのか
* 所有権の部分はこの章の後の方でスタックとヒープに関連して議論されるので、ここでは準備として簡潔に説明する
* スタックとヒープ両方は、実行時にあなたのコードで利用できるメモリーの一部分だが、それらは違った方法で構築されている
  * スタックは値を来た順番で保存し、逆順で値を削除する
    * これは _last in, first out_ と言われている
  * 皿の積み重ねを考えてみよう
    * より多くの皿を加えるとき、積み重ねのてっぺんにそれらを置く
    * もし皿が必要になったら、てっぺんから皿をとる
    * 下部や中央への皿の追加や削除はどちらもできないだろう
  * データの追加はスタックへプッシュすると呼ばれ、削除はスタックからポップすると呼ばれる
  * データへのアクセスの仕方のおかげでスタックは速い
    * データを取得するところは常にてっぺんのなので、新しいデータの場所や取得したいデータの場所を探す必要がない
    * スタックを速くするもう一つの性質は、スタックのデータは既に知られている固定サイズ分だけ占められている
  * コンパイル時にサイズが未知なデータやサイズが変わる可能性があるデータは、スタックの代わりにヒープに保存できる
    * ヒープはあまり整理されておらず、データをヒープに置くときに、あなたはいくらかのスペースを要求する
    * OS がヒープのどこかに十分な大きさの空きの場所を見つけ、使用中だと印をつけ、その場所の住所であるポインターを返す
      * このプロセスはヒープでの割り当てと呼ばれ、時々ただ「割り当て」と略される
  * 値をスタックへプッシュすることは割り当てとは考えられていない
    * なぜなら、そのポインターは既知で、長さが固定で、スタック上にポインターを保存できるから
    * だが、実際のデータが欲しいとき、ポインターを追う必要がある
  * レストランで座ることを考えてみよう
    * あなたが入店したとき、あなたのグループの人数を述べて全員が座れる空いているテーブルを探し、そこに導く
    * もしあなたのグループの誰かが遅れてきたら、あなたを探すために、あなたがどこに座ったかを聞くことができる
* データを得るためにポインターを追わなければならないので、ヒープでのデータアクセスは、スタックでのデータアクセスより遅い
  * 現代のプロセッサーは、メモリー内のジャンプを抑えれば速い
  * レストランの比喩を続けるが、多くのテーブルから注文を取るサーバーを考えてみよう
    * 次のテーブルに移る前に一つのテーブルの注文を一度にすべて集めるのが一番効率がいい
    * テーブル A から注文を取って、それからテーブル B で注文を取って、A からまた取って B からもまた取るとなると、とても遅い作業になる
  * 同じように、プロセッサーは、データ同士が遠いよりも近いほうがよりいい感じに処理できる
    * スタックのデータは互いに近く、ヒープのデータは互いに遠い
  * ヒープでの大きなスペースの割り当てもまた時間がかかる
* あなたのコードが関数を呼ぶとき、値は関数に渡され、関数のローカル変数はスタックにプッシュされる
  * 関数に渡される値は、ヒープ上のデータへのポインターである可能性もある
  * 関数の実行が終了したとき、それらの値はスタックからポップされる
* 所有権システムは以下の問題に対処する
  * コードのどの部分がヒープ上の何のデータを使っているかを追跡する
  * ヒープ上のデータの重複を最小化
  * ヒープ上の使われていないデータを取り除くことで、メモリーの枯渇を防ぐ
* いったん所有権システムを理解すれば頻繁にスタックやヒープについて考える必要がなくなるが、ヒープのデータを管理することを知っていると、なぜ所有権システムが存在し、なぜそれがそのように動くかを説明する助けになる

---
