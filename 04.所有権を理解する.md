# 所有権を理解する

* 所有権は Rust の最も特異な機能で、ガベージコレクター無しで Rust がメモリ安全性を保障できるようにするものだ
* したがって、Rust で所有権がどのように働くかを理解しておくことは重要だ
* この章では、所有権やいくつかの関連する機能について話していく
  * 借用
  * スライス
  * Rust のメモリーレイアウトの仕方

## 所有権とは何？

* Rust の中心的な機能は所有権だ
  * 機能を説明するのは複雑ではないが、言語の残りの部分に対する深い含蓄を持っている
* すべてのプログラムは実行時のコンピューターのメモリーの使い方を管理しなければならない
  * いくつかの言語は、プログラムの実行時にもう使われなくなったメモリーを常に見張るガベージコレクションを持っている
  * そのほかの言語では、プログラマーが明示的にメモリーの割り当てと解除を行わなければならない
  * Rust では、三つ目のアプローチをとっている
    * コンパイル時にコンパイラーがチェックする規則の組を伴った所有権システムでメモリーを管理している
    * どの所有権の機能も実行時にプログラムを遅くしない
* 多くのプログラマーにとって所有権は新しい概念なので、それに慣れるためにいくらかの時間をかける
* ここでよいニュース
  * Rust と所有権システムを経験すればするほど、安全で効率的なコードを自然に開発できるようになる。がんばって！
* 所有権を理解したとき、Rust を特異たらしめる機能を理解するための確固たる基礎を持つことになるだろう
* この章では、とっても一般的なデータ構造である文字列に焦点を当てて例に取り組むことで、所有権を学んでいくことになるだろう

---

### スタックとヒープ

* 多くの言語では、スタックとヒープについてはそれほど考える必要はない
* しかし、Rust のようなシステムプログラミング言語では、値がスタックとヒープどちらかにあるかはより効力を持っている
  * どのように言語が振る舞うか
  * なぜあなたがそのような決定を下したのか
* 所有権の部分はこの章の後の方でスタックとヒープに関連して議論されるので、ここでは準備として簡潔に説明する
* スタックとヒープ両方は、実行時にあなたのコードで利用できるメモリーの一部分だが、それらは違った方法で構築されている
  * スタックは値を来た順番で保存し、逆順で値を削除する
    * これは _last in, first out_ と言われている
  * 皿の積み重ねを考えてみよう
    * より多くの皿を加えるとき、積み重ねのてっぺんにそれらを置く
    * もし皿が必要になったら、てっぺんから皿をとる
    * 下部や中央への皿の追加や削除はどちらもできないだろう
  * データの追加はスタックへプッシュすると呼ばれ、削除はスタックからポップすると呼ばれる
  * データへのアクセスの仕方のおかげでスタックは速い
    * データを取得するところは常にてっぺんのなので、新しいデータの場所や取得したいデータの場所を探す必要がない
    * スタックを速くするもう一つの性質は、スタックのデータは既に知られている固定サイズ分だけ占められている
  * コンパイル時にサイズが未知なデータやサイズが変わる可能性があるデータは、スタックの代わりにヒープに保存できる
    * ヒープはあまり整理されておらず、データをヒープに置くときに、あなたはいくらかのスペースを要求する
    * OS がヒープのどこかに十分な大きさの空きの場所を見つけ、使用中だと印をつけ、その場所の住所であるポインターを返す
      * このプロセスはヒープでの割り当てと呼ばれ、時々ただ「割り当て」と略される
  * 値をスタックへプッシュすることは割り当てとは考えられていない
    * なぜなら、そのポインターは既知で、長さが固定で、スタック上にポインターを保存できるから
    * だが、実際のデータが欲しいとき、ポインターを追う必要がある
  * レストランで座ることを考えてみよう
    * あなたが入店したとき、あなたのグループの人数を述べて全員が座れる空いているテーブルを探し、そこに導く
    * もしあなたのグループの誰かが遅れてきたら、あなたを探すために、あなたがどこに座ったかを聞くことができる
* データを得るためにポインターを追わなければならないので、ヒープでのデータアクセスは、スタックでのデータアクセスより遅い
  * 現代のプロセッサーは、メモリー内のジャンプを抑えれば速い
  * レストランの比喩を続けるが、多くのテーブルから注文を取るサーバーを考えてみよう
    * 次のテーブルに移る前に一つのテーブルの注文を一度にすべて集めるのが一番効率がいい
    * テーブル A から注文を取って、それからテーブル B で注文を取って、A からまた取って B からもまた取るとなると、とても遅い作業になる
  * 同じように、プロセッサーは、データ同士が遠いよりも近いほうがよりいい感じに処理できる
    * スタックのデータは互いに近く、ヒープのデータは互いに遠い
  * ヒープでの大きなスペースの割り当てもまた時間がかかる
* あなたのコードが関数を呼ぶとき、値は関数に渡され、関数のローカル変数はスタックにプッシュされる
  * 関数に渡される値は、ヒープ上のデータへのポインターである可能性もある
  * 関数の実行が終了したとき、それらの値はスタックからポップされる
* 所有権システムは以下の問題に対処する
  * コードのどの部分がヒープ上の何のデータを使っているかを追跡する
  * ヒープ上のデータの重複を最小化
  * ヒープ上の使われていないデータを取り除くことで、メモリーの枯渇を防ぐ
* いったん所有権システムを理解すれば頻繁にスタックやヒープについて考える必要がなくなるが、ヒープのデータを管理することを知っていると、なぜ所有権システムが存在し、なぜそれがそのように動くかを説明する助けになる

---

### 所有権の規則

* 最初に、所有権の規則を見てみよう
* 所有権について描写する例を見るときにこれらの規則を心に留めておこう
  * Rust での値それぞれは、所有者と呼ばれる変数を持っている
  * 変数は一度にただ一つの値の所有者となる
  * 所有者がスコープを抜けたとき、値は破棄される

### 変数のスコープ

* 2 章で既に Rust のプログラムの例を見てきた
  * 私たちは基本的な文法を経たので、例において全ての `fn main() {` のコードを含めないようにするだろう
  * なので、以降も例に沿って行くなら、以下の例を `main` 関数の中に手動で置かなければならない
  * 結果として、例はもう少し簡潔になり、冗長なコードより実際的な詳細に焦点を当てていくようになる
* 最初の所有権の例として、いくつかの変数のスコープを見ていこう
  * スコープはプログラム内の項目が有効である範囲
  * 以下のような変数があるとしよう

```rust
let s = "hello";
```

* 変数 `s` は文字列リテラルを参照し、文字列の値はプログラムのテキストの中にハードコーディングされている
* 変数は、宣言された時点から、現在のスコープの終わりまで有効
* Listing 4-1 は、変数 `s` がどこで有効かを注釈したコメントを含んでいる

```rust
{                   // s はここでは有効ではない。まだ宣言されていないので
  let s = "hello";  // s はこの時点から以降有効

  // s で何かする
}                   // このスコープは今終わって、s はもはや有効ではない
```

Listing 4-1: 変数とそれが有効なスコープ

* 言い換えると、ここでは重要な点が二つある
  * `s` がスコープ内に来た時、それは有効になる
  * スコープ外に出るまでそれは有効なまま
* この時点では、スコープと、変数がいつ有効なのかの関係はほかのプログラミング言語と似ている
  * これから `String` 型を導入することで、この理解の上に話を建てていく

### `String` 型

* 所有権の規則を描写するために、3 章の「データ型」節で網羅したものより複雑なデータ型を必要としている
  * 以前網羅した型は全てスタックに保存され、スコープを抜けたときにスタックから取り出されるが、ヒープに保存されるデータを見て、Rust がどのようにしてデータを片付ける時が来たと知るのかを探求したい
* ここの例として `String` を使い、`String` の所有権に関係のある部分に集中する
  * これらの側面はまた、標準ライブラリーによって提供されるか、あなたが作成する他の複雑なデータ型にも適用される
  * `String` について 8 章でより深く議論する
* 私たちは既に文字列リテラルを見たことがあり、そこで文字列の値が私たちのプログラムへハードコーディングされていた
  * 文字列リテラルは便利だが、テキストを使いたい全ての場合において適しているわけではない
    * 理由の一つは、それらが不変であることだ
    * もう一つの理由は、コードを書くときに全ての文字列が既知というわけではないことだ
      * 例えば、ユーザーの入力を受け取って保存するのはどうだろうか？
  * このような場合に、Rust は `String` という二番目の文字列型を持っている
    * この型はヒープに割り当てられ、コンパイル時に未知である量のテキストを保存できる
* 以下のように `from` 関数を使って、文字列リテラルから `String` を作成できる

```rust
let s = String::from("hello");
```

* 二重コロン演算子 `::` は、`string_from` のような名前を利用する場合よりも、`String` 型の下の特定の `from` 関数を名前空間において扱えるようにする
  * この文法について 5 章の「メソッド文法」の節でもっと議論し、7 章の「モジュール木における項目を参照するパス」で、モジュールを伴った名前空間について話す
* この種の文字列は可変である

```rust
let mut s = String::from("hello");

s.push_str(", world!"); // push_str() は String に文字列リテラルを追加する

println!("{}", s); // これは `hello, world!` を出力する
```

* それで、ここでは何が違っているのだろうか？
* なぜ `String` は可変で文字列リテラルは不変なのか？
* この違いは、これら二つの型がどのようにメモリーで扱われているかによる

### メモリーと割り当て

* 文字列リテラルの場合、コンパイル時に内容を知っているので、テキストは最終的な実行ファイルに直接ハードコーディングされる
  * これが、文字列リテラルが速くて効率的な理由だ
* しかし、これらの特性は文字列リテラルの不変性から来ているだけだ
* 不幸なことに、コンパイル時にサイズが未知だったり、プログラムの実行時にサイズが変わるかもしれないテキスト片は、メモリーの塊として実行ファイルへ埋め込むことができない
* `String` 型では、可変性とテキスト片の伸長をサポートするため、コンパイル時に未知の内容を保持するメモリーをヒープに割り当てる必要がある
  * これは以下のことを意味している
    * メモリーは実行時に OS からリクエストされなければならない
      * これは私たちによってなされる
        * `String::from` を呼ぶとき、その実装は必要な分のメモリーをリクエストする
        * これはプログラミング言語ではとても普遍的なものだ
    * `String` を使い終わったとき、OS へこのメモリーを返す手段が必要
      * しかし、これは自然に為されるものではない
        * ガベージコレクター (GC) を伴った言語では、GC がもう使われていないメモリーを追跡して掃除し、私たちはそのことについて考える必要がない
        * GC なしだと、メモリーがもう使われなくなった時を識別して、丁度メモリーをリクエストしたように、それを返すコードを明示的に呼び出す責任が私たちにある
          * 歴史的観点からみて、これを正しく為すのは難しいプログラミングの問題だ
            * もしそれを忘れると、メモリーを無駄にすることになる
            * もしそれを早く行いすぎると、無効な変数を持つことになる
            * もしそれを二度行うと、それもまたバグである
              * 私たちは、ちょうど一つの `allocate` と、ちょうど一つの `free` を組にする必要がある
        * Rust は違った方法をとる
          * メモリーを所有する変数がスコープ外に抜けると、メモリーが自動的に返還される
          * 以下は、Listing 4-1 のスコープ例を、文字列リテラルの代わりに `String` を使った版である

```rust
{
  let s = String::from("hello");  // s はこの時点から以降有効

  // s で何かする
}                                 // このスコープは今終わって、s はもはや有効ではない
```

* `String` が必要とするメモリーを OS へ返す自然な点がある
  * その点とは、`s` がスコープ外へと抜けるとき
* 変数がスコープ外へ抜けるとき、Rust は私たちのために特別な関数を呼び出す
  * この関数は `drop` と呼ばれていて、それは `String` の作者がメモリーを返還するコードを置ける場所だ
  * Rust は波括弧が閉じられる所で自動的に `drop` を呼び出す

---
Note:

* C++ では、項目の寿命の終わりにリソースの割り当てを解除するこのパターンは時々 _Resource Acquisition Is Initialization (RAII)_ と呼ばれている
* Rust における `drop` 関数は、RAII パターンを使ったことがあるなら親しみやすいものだろう

---

* このパターンは Rust のコードの書き方に広範囲な影響を与える
* 今は単純に見えるかもしれないが、より複雑な状況ではコードの振る舞いが予測不能になり得る
  * ヒープに割り当てたデータを使う複数の変数を持ちたい時など
* 今からいくつかのそのような状況を探求してみよう

### 変数やデータとのふれあい方: ムーブ

* Rust では、複数の変数から同じデータに対して違った方法で相互作用できる
* Listing 4-2 の整数を使った例を見てみよう

```rust
let x = 5;
let y = x;
```

Listing 4-2: 変数 `x` の整数の値を `y` へと代入

* これが何をしているかを推測できるかもしれない
  * 「値 `5` を `x` へ束縛する。そして、`x` の値のコピーを作成し、それを `y` へと束縛する。」
  * これが起こっていることは確かだ。なぜなら整数は
    * 既知の単純な値
    * 固定長
    * これら二つの値 `5` はスタックへプッシュされる
* `String` 版を見てみよう

```rust
let s1 = String::from("hello");
let s2 = s1;
```
