# 所有権を理解する

* 所有権は Rust の最も特異な機能で、ガベージコレクター無しで Rust がメモリ安全性を保障できるようにするものだ
* したがって、Rust で所有権がどのように働くかを理解しておくことは重要だ
* この章では、所有権やいくつかの関連する機能について話していく
  * 借用
  * スライス
  * Rust のメモリーレイアウトの仕方

## 所有権とは何？

* Rust の中心的な機能は所有権だ
  * 機能を説明するのは複雑ではないが、言語の残りの部分に対する深い含蓄を持っている
* すべてのプログラムは実行時のコンピューターのメモリーの使い方を管理しなければならない
  * いくつかの言語は、プログラムの実行時にもう使われなくなったメモリーを常に見張るガベージコレクションを持っている
  * そのほかの言語では、プログラマーが明示的にメモリーの割り当てと解除を行わなければならない
  * Rust では、三つ目のアプローチをとっている
    * コンパイル時にコンパイラーがチェックする規則の組を伴った所有権システムでメモリーを管理している
    * どの所有権の機能も実行時にプログラムを遅くしない
* 多くのプログラマーにとって所有権は新しい概念なので、それに慣れるためにいくらかの時間をかける
* ここでよいニュース
  * Rust と所有権システムを経験すればするほど、安全で効率的なコードを自然に開発できるようになる。がんばって！
* 所有権を理解したとき、Rust を特異たらしめる機能を理解するための確固たる基礎を持つことになるだろう
* この章では、とっても一般的なデータ構造である文字列に焦点を当てて例に取り組むことで、所有権を学んでいくことになるだろう

---

### スタックとヒープ

* 多くの言語では、スタックとヒープについてはそれほど考える必要はない
* しかし、Rust のようなシステムプログラミング言語では、値がスタックとヒープどちらかにあるかはより効力を持っている
  * どのように言語が振る舞うか
  * なぜあなたがそのような決定を下したのか
* 所有権の部分はこの章の後の方でスタックとヒープに関連して議論されるので、ここでは準備として簡潔に説明する
* スタックとヒープ両方は、実行時にあなたのコードで利用できるメモリーの一部分だが、それらは違った方法で構築されている
  * スタックは値を来た順番で保存し、逆順で値を削除する
    * これは _last in, first out_ と言われている
  * 皿の積み重ねを考えてみよう
    * より多くの皿を加えるとき、積み重ねのてっぺんにそれらを置く
    * もし皿が必要になったら、てっぺんから皿をとる
    * 下部や中央への皿の追加や削除はどちらもできないだろう
  * データの追加はスタックへプッシュすると呼ばれ、削除はスタックからポップすると呼ばれる
  * データへのアクセスの仕方のおかげでスタックは速い
    * データを取得するところは常にてっぺんのなので、新しいデータの場所や取得したいデータの場所を探す必要がない
    * スタックを速くするもう一つの性質は、スタックのデータは既に知られている固定サイズ分だけ占められている
  * コンパイル時にサイズが未知なデータやサイズが変わる可能性があるデータは、スタックの代わりにヒープに保存できる
    * ヒープはあまり整理されておらず、データをヒープに置くときに、あなたはいくらかのスペースを要求する
    * OS がヒープのどこかに十分な大きさの空きの場所を見つけ、使用中だと印をつけ、その場所の住所であるポインターを返す
      * このプロセスはヒープでの割り当てと呼ばれ、時々ただ「割り当て」と略される
  * 値をスタックへプッシュすることは割り当てとは考えられていない
    * なぜなら、そのポインターは既知で、長さが固定で、スタック上にポインターを保存できるから
    * だが、実際のデータが欲しいとき、ポインターを追う必要がある
  * レストランで座ることを考えてみよう
    * あなたが入店したとき、あなたのグループの人数を述べて全員が座れる空いているテーブルを探し、そこに導く
    * もしあなたのグループの誰かが遅れてきたら、あなたを探すために、あなたがどこに座ったかを聞くことができる
* データを得るためにポインターを追わなければならないので、ヒープでのデータアクセスは、スタックでのデータアクセスより遅い
  * 現代のプロセッサーは、メモリー内のジャンプを抑えれば速い
  * レストランの比喩を続けるが、多くのテーブルから注文を取るサーバーを考えてみよう
    * 次のテーブルに移る前に一つのテーブルの注文を一度にすべて集めるのが一番効率がいい
    * テーブル A から注文を取って、それからテーブル B で注文を取って、A からまた取って B からもまた取るとなると、とても遅い作業になる
  * 同じように、プロセッサーは、データ同士が遠いよりも近いほうがよりいい感じに処理できる
    * スタックのデータは互いに近く、ヒープのデータは互いに遠い
  * ヒープでの大きなスペースの割り当てもまた時間がかかる
* あなたのコードが関数を呼ぶとき、値は関数に渡され、関数のローカル変数はスタックにプッシュされる
  * 関数に渡される値は、ヒープ上のデータへのポインターである可能性もある
  * 関数の実行が終了したとき、それらの値はスタックからポップされる
* 所有権システムは以下の問題に対処する
  * コードのどの部分がヒープ上の何のデータを使っているかを追跡する
  * ヒープ上のデータの重複を最小化
  * ヒープ上の使われていないデータを取り除くことで、メモリーの枯渇を防ぐ
* いったん所有権システムを理解すれば頻繁にスタックやヒープについて考える必要がなくなるが、ヒープのデータを管理することを知っていると、なぜ所有権システムが存在し、なぜそれがそのように動くかを説明する助けになる

---

### 所有権の規則

* 最初に、所有権の規則を見てみよう
* 所有権について描写する例を見るときにこれらの規則を心に留めておこう
  * Rust での値それぞれは、所有者と呼ばれる変数を持っている
  * 変数は一度にただ一つの値の所有者となる
  * 所有者がスコープを抜けたとき、値は破棄される

### 変数のスコープ

* 2 章で既に Rust のプログラムの例を見てきた
  * 私たちは基本的な文法を経たので、例において全ての `fn main() {` のコードを含めないようにするだろう
  * なので、以降も例に沿って行くなら、以下の例を `main` 関数の中に手動で置かなければならない
  * 結果として、例はもう少し簡潔になり、冗長なコードより実際的な詳細に焦点を当てていくようになる
* 最初の所有権の例として、いくつかの変数のスコープを見ていこう
  * スコープはプログラム内の項目が有効である範囲
  * 以下のような変数があるとしよう

```rust
let s = "hello";
```

* 変数 `s` は文字列リテラルを参照し、文字列の値はプログラムのテキストの中にハードコーディングされている
* 変数は、宣言された時点から、現在のスコープの終わりまで有効
* Listing 4-1 は、変数 `s` がどこで有効かを注釈したコメントを含んでいる

```rust
{                   // s はここでは有効ではない。まだ宣言されていないので
  let s = "hello";  // s はこの時点から以降有効

  // s で何かする
}                   // このスコープは今終わって、s はもはや有効ではない
```

Listing 4-1: 変数とそれが有効なスコープ

* 言い換えると、ここでは重要な点が二つある
  * `s` がスコープ内に来た時、それは有効になる
  * スコープ外に出るまでそれは有効なまま
* この時点では、スコープと、変数がいつ有効なのかの関係はほかのプログラミング言語と似ている
  * これから `String` 型を導入することで、この理解の上に話を建てていく

### `String` 型

* 所有権の規則を描写するために、3 章の「データ型」節で網羅したものより複雑なデータ型を必要としている
  * 以前網羅した型は全てスタックに保存され、スコープを抜けたときにスタックから取り出されるが、ヒープに保存されるデータを見て、Rust がどのようにしてデータを片付ける時が来たと知るのかを探求したい
* ここの例として `String` を使い、`String` の所有権に関係のある部分に集中する
  * これらの側面はまた、標準ライブラリーによって提供されるか、あなたが作成する他の複雑なデータ型にも適用される
  * `String` について 8 章でより深く議論する
* 私たちは既に文字列リテラルを見たことがあり、そこで文字列の値が私たちのプログラムへハードコーディングされていた
  * 文字列リテラルは便利だが、テキストを使いたい全ての場合において適しているわけではない
    * 理由の一つは、それらが不変であることだ
    * もう一つの理由は、コードを書くときに全ての文字列が既知というわけではないことだ
      * 例えば、ユーザーの入力を受け取って保存するのはどうだろうか？
  * このような場合に、Rust は `String` という二番目の文字列型を持っている
    * この型はヒープに割り当てられ、コンパイル時に未知である量のテキストを保存できる
* 以下のように `from` 関数を使って、文字列リテラルから `String` を作成できる

```rust
let s = String::from("hello");
```

* 二重コロン演算子 `::` は、`string_from` のような名前を利用する場合よりも、`String` 型の下の特定の `from` 関数を名前空間において扱えるようにする
  * この文法について 5 章の「メソッド文法」の節でもっと議論し、7 章の「モジュール木における項目を参照するパス」で、モジュールを伴った名前空間について話す
* この種の文字列は可変である

```rust
let mut s = String::from("hello");

s.push_str(", world!"); // push_str() は String に文字列リテラルを追加する

println!("{}", s); // これは `hello, world!` を出力する
```

* それで、ここでは何が違っているのだろうか？
* なぜ `String` は可変で文字列リテラルは不変なのか？
* この違いは、これら二つの型がどのようにメモリーで扱われているかによる

### メモリーと割り当て

* 文字列リテラルの場合、コンパイル時に内容を知っているので、テキストは最終的な実行ファイルに直接ハードコーディングされる
  * これが、文字列リテラルが速くて効率的な理由だ
* しかし、これらの特性は文字列リテラルの不変性から来ているだけだ
* 不幸なことに、コンパイル時にサイズが未知だったり、プログラムの実行時にサイズが変わるかもしれないテキスト片は、メモリーの塊として実行ファイルへ埋め込むことができない
* `String` 型では、可変性とテキスト片の伸長をサポートするため、コンパイル時に未知の内容を保持するメモリーをヒープに割り当てる必要がある
  * これは以下のことを意味している
    * メモリーは実行時に OS からリクエストされなければならない
      * これは私たちによってなされる
        * `String::from` を呼ぶとき、その実装は必要な分のメモリーをリクエストする
        * これはプログラミング言語ではとても普遍的なものだ
    * `String` を使い終わったとき、OS へこのメモリーを返す手段が必要
      * しかし、これは自然に為されるものではない
        * ガベージコレクター (GC) を伴った言語では、GC がもう使われていないメモリーを追跡して掃除し、私たちはそのことについて考える必要がない
        * GC なしだと、メモリーがもう使われなくなった時を識別して、丁度メモリーをリクエストしたように、それを返すコードを明示的に呼び出す責任が私たちにある
          * 歴史的観点からみて、これを正しく為すのは難しいプログラミングの問題だ
            * もしそれを忘れると、メモリーを無駄にすることになる
            * もしそれを早く行いすぎると、無効な変数を持つことになる
            * もしそれを二度行うと、それもまたバグである
              * 私たちは、ちょうど一つの `allocate` と、ちょうど一つの `free` を組にする必要がある
        * Rust は違った方法をとる
          * メモリーを所有する変数がスコープ外に抜けると、メモリーが自動的に返還される
          * 以下は、Listing 4-1 のスコープ例を、文字列リテラルの代わりに `String` を使った版である

```rust
{
  let s = String::from("hello");  // s はこの時点から以降有効

  // s で何かする
}                                 // このスコープは今終わって、s はもはや有効ではない
```

* `String` が必要とするメモリーを OS へ返す自然な点がある
  * その点とは、`s` がスコープ外へと抜けるとき
* 変数がスコープ外へ抜けるとき、Rust は私たちのために特別な関数を呼び出す
  * この関数は `drop` と呼ばれていて、それは `String` の作者がメモリーを返還するコードを置ける場所だ
  * Rust は波括弧が閉じられる所で自動的に `drop` を呼び出す

---
Note:

* C++ では、項目の寿命の終わりにリソースの割り当てを解除するこのパターンは時々 _Resource Acquisition Is Initialization (RAII)_ と呼ばれている
* Rust における `drop` 関数は、RAII パターンを使ったことがあるなら親しみやすいものだろう

---

* このパターンは Rust のコードの書き方に広範囲な影響を与える
* 今は単純に見えるかもしれないが、より複雑な状況ではコードの振る舞いが予測不能になり得る
  * ヒープに割り当てたデータを使う複数の変数を持ちたい時など
* 今からいくつかのそのような状況を探求してみよう

#### 変数やデータとのふれあい方: Move

* Rust では、複数の変数から同じデータに対して違った方法で相互作用できる
* Listing 4-2 の整数を使った例を見てみよう

```rust
let x = 5;
let y = x;
```

Listing 4-2: 変数 `x` の整数の値を `y` へと代入

* これが何をしているかを推測できるかもしれない
  * 「値 `5` を `x` へ束縛する。そして、`x` の値のコピーを作成し、それを `y` へと束縛する。」
  * これが起こっていることは確かだ。なぜなら整数は
    * 既知の単純な値
    * 固定長
    * これら二つの値 `5` はスタックへプッシュされる
* `String` 版を見てみよう

```rust
let s1 = String::from("hello");
let s2 = s1;
```

* これは前のコードにとても似ているので、同じように動くことを仮定できるかもしれない
* `String` は以下の図の左の表で示すように、三つの部分からできている
  * 文字列の内容を保持するメモリーへのポインター
  * 長さ
  * キャパシティー
* このデータの組はスタックに保存される
* 以下の図の右の表は、その内容を保持するヒープ上のメモリーだ

![Figure 4-1](https://doc.rust-lang.org/book/img/trpl04-01.svg)

Figure 4-1: `s1` に束縛された値 `hello` を保持する `String` のメモリー上の表現

* 長さは、現在 `String` の内容がどのくらいメモリーを使用しているかを表している
  * 長さはバイト単位
* キャパシティーは、OS から受け取った、`String` のメモリー量の総量だ
  * キャパシティーはバイト単位
* 長さとキャパシティーの間の違いは問題となるが、今のところここの文脈ではキャパシティーは無視してもよい
* `s1` を `s2` へ代入するとき、`String` のスタック上のデータはコピーされる
  * 以下のものをコピーする
    * ヒープ上の文字列の内容へのポインター
    * 長さ
    * キャパシティー
  * ポインターが参照するヒープ上のデータはコピーしない
  * 言い換えると、メモリー上のデータ表現は Figure 4-2 のように見える

![Figure 4-2](https://doc.rust-lang.org/book/img/trpl04-02.svg)

Figure 4-2: `s1` のポインター、長さ、キャパシティーのコピーを持つ、変数 `s2` のメモリー上の表現

* そのメモリー表現は Figure 4-3 のようにはならない
  * Figure 4-3 は、Figure 4-2 のようになる代わりに、Rust がヒープ上のデータもコピーしたかのように見える
  * もし Rust がこのようにしたなら、`s2 = s1` のオペレーションは、ヒープ上のデータが大きい場合の実行時パフォーマンスの観点において非常に高くつくことがあり得る

![Figure 4-3](https://doc.rust-lang.org/book/img/trpl04-03.svg)

Figure 4-3: もし Rust がヒープ上のデータも同じようにコピーした場合に `s2 = s1` がし得るもう一つの可能性

* 前の方では、変数がスコープ外に出たとき、Rust は自動的に `drop` 関数を呼んで、変数に対するヒープ上のメモリーを開放すると言った
* しかし、Figure 4-2 では、両方のデータポインターが同じ場所を指していることを示している
  * これは問題だ
  * `s2` と `s1` がスコープ外に出たとき、両方同じメモリーを開放しようとする
  * これは _double free_ エラーとして知られており、前の方で言ったメモリー安全性におけるバグの一つだ
  * メモリーを二度開放するのはメモリー破壊を引き起こすことがある
    * セキュリティーの脆弱性を引き起こすことがあり得る
* メモリー安全性を確かのものにするために、Rust においてこの状況で何が起こるかのもう一つの詳細がある
  * 割り当てられたメモリーのコピーを試みる代わりに、Rust は `s1` がもはや有効でないと考え、`s1` がスコープ外に出たときにどのメモリーも開放する必要がないと解釈する
  * `s2` が作成された後、`s1` を使おうとしてしまうと何が起こるかを見てみよう
    * 動かないはずだ

```rust
let s1 = String::from("hello");
let s2 = s1;

println!("{}, world!", s1);
```

* Rust が、無効化された参照の使用を防ごうとするため、以下のようなエラーが出る

```bash
error[E0382]: use of moved value: `s1`
 --> src/main.rs:5:28
  |
3 |     let s2 = s1;
  |         -- value moved here
4 |
5 |     println!("{}, world!", s1);
  |                            ^^ value used here after move
  |
  = note: move occurs because `s1` has type `std::string::String`, which does
  not implement the `Copy` trait
```

* もし他の言語に取り組んでいる間に _shallow copy_ や _deep copy_ といった用語聞いたことがあるなら、内容データはコピーせず、ポインターや長さやキャパシティーをコピーするという概念は _shallow copy_ のように聞こえるかもしれない
  * しかし、Rust は最初の変数の無効化もするため、_shallow copy_ と呼ぶ代わりに _move_ として知られている
  * この例では、`s1` は `s2` へ _move_ されたといえる
  * なので、実際に何が起きているかは Figure 4-4 で示されている

![Figure 4-4](https://doc.rust-lang.org/book/img/trpl04-04.svg)

Figure 4-4: `s1` が無効化された後のメモリー表現

* これは私たちの問題を解決する！
  * `s2` のみが有効なことで、`s2` がスコープ外に出たとき、文字列の内容のヒープ上のメモリーを一度だけ開放する
  * 加えて、これによって設計上の選択肢があることが暗に示唆される
    * Rust は決してあなたのデータの _deep copy_ を自動作成しない
    * したがって、どの自動的なコピーも、実行時パフォーマンスの観点で安くつくと仮定できる

#### 変数やデータとのふれあい方: Clone

* `String` の、スタックだけではなくヒープのデータも _deep copy_ したいなら、`clone` と呼ばれる一般的なメソッドを使うことができる
  * メソッドの文法は 5 章で議論するだろうが、メソッドは多くのプログラミング言語で一般的なので、それらを以前に見たことがあるかもしれない
* 以下は `clone` メソッドの実際の例だ

```rust
let s1 = String::from("hello");
let s2 = s1.clone();

println!("s1 = {}, s2 = {}", s1, s2);
```

* これはちゃんと動き、Figure 4-3 で示された振る舞いを明示的に作り出す
  * ヒープのデータがコピーされる
* `clone` の呼び出しを見る時、いくらかの任意のコードが実行され、そのコードは実行コストが高いかもしれない事を知ることになる
  * これは、何か普通とは違ったことが行われているという視覚的な指標だ

#### スタックだけにあるデータ: Copy

* まだ話していないもう一つの趣向がある
* Listing 4-2 で示されている一部の整数を使った以下のコードはちゃんと動作し、有効なものだ

```rust
let x = 5;
let y = x;

println!("x = {}, y = {}", x, y);
```

* しかしこのコードはついさっき学んだことと相反するように見える
  * `clone` の呼び出しが無いが、`x` は依然として有効で、`y` へと _move_ されていない
  * その理由は、コンパイル時にサイズが既知の整数のような型は全体がスタックに保存されるので、実際の値のコピーが高速に作成できるからというものだ
  * それは、変数 `y` を作成した後に、`x` が有効なままになるのを防止する理由が無い事を意味する
  * 言い換えると、ここでは _deep copy_ と _shallow copy_ の間の違いがないので、`clone` の呼び出しは通常の _shallow copy_ と何ら変わらず、そのままにしておけるということだ
* Rust は `Copy` トレイトと呼ばれる、スタックに保存できる整数型のような型に置くことができる特別な注釈を持っている
  * 10 章でトレイトについてもっと話す
  * もしとある型が `Copy` トレイトを持っていたら、代入の後でも古い値を依然として使うことができる
  * もしとある型、またその方の一部が `Drop` トレイトを実装しているなら、Rust はその型を `Copy` トレイトで注釈させない
    * もしその型が、スコープを抜けた時に何か特別なことをする必要があって、その型に `Copy` 注釈を追加したなら、コンパイルエラーが出るだろう
  * あなたが作った型にどのようにして `Copy` 注釈を追加するかについて学ぶなら、付録 C の「派生可能なトレイト」を見ること
* それで、何の型が `Copy` なのだろうか？
  * 与えられた型に対してドキュメントをチェックすれば確かめられるが、一般的な規則として、単純なスカラー値のグループが `Copy` になることができ、メモリー割り当てや何らかの形のリソースを何も必要としないのが `Copy` だ
  * 以下がいくつかの `Copy` である型だ
    * `u32` のような全ての整数型
    * 値が `true` と `false` であるブーリアン型の `bool`
    * `f64` のような全ての浮動小数点型
    * 文字型の `char`
    * 含まれている型もまた `Copy` である場合のタプル
      * 例えば `(i32, i32)` は `Copy` だが、`(i32, String)` はそうではない
