# 一般的なプログラミングの概念

* この章では、ほぼ全てのプログラミング言語で現れる概念と、Rust でそれらがどのように動くかを網羅する
  * 多くのプログラミング言語は中核部分が共通している
  * この章で現れる概念で Rust 特有のものはないが、それらを Rust の文脈で述べて、それらの概念の周りにある習慣を説明する
* 特に、以下のものを学ぶ
  * 変数
  * 基本的な型
  * 関数
  * コメント
  * 制御フロー
* これらの基礎は全ての Rust プログラムにあり、早期にそれらを学ぶことは、出発点の強固な中核を得ることになるだろう

---

## キーワード

* Rust には一連の *keyword* がある
  * 他の言語のように、言語でのみ使用されるように予約されている
* これらのキーワードは、変数や関数の名前として使えないことを心に留めておかなければならない
* 殆どのキーワードは特別な意味を持っていて、Rust のプログラムで様々なことをこなすために使う
  * いくつかは現在機能が割り当てられていないが、 Rust に将来追加される機能のために予約されている
* キーワードの一覧は付録 A で見つかる

---

## 変数と可変性

* 2 章で述べたように、デフォルトで変数は不変
  * これは数多くある、並列性の利点を安全で簡単に享受するための Rust の後押しの一つ
* しかし、変数を可変とする選択肢も依然としてある
* Rust が、なぜ、どのようにして普遍性を好むように奨励するのか、そして、なぜ時々それを覆したくなることがあるかを見ていこう
* 変数が不変の時、一度値が名前に束縛されたら、その値を変更することができない
* これを表すために *variables* と呼ばれる新しいプロジェクトを `cargo new variables` を用いて *projects* ディレクトリの中に生成しよう
* そして、新しい *variables* ディレクトリの中で *src/main.rs* を開いて、以下のコードで置き換える
  * まだコンパイルできない

ファイル名: src/main.rs

```rust
fn main() {
  let x = 5;
  println!("The value of x is: {}", x);
  x = 6;
  println!("The value of x is :{}", x);
}
```

* 保存して `cargo run` でプログラムを実行する
* エラーメッセージを受け取るはずで、このような出力が表示される

```bash
error[E0384]: cannot assign twice to immutable variable `x`
 --> src/main.rs:4:5
  |
2 |     let x = 5;
  |         - first assignment to `x`
3 |     println!("The value of x is: {}", x);
4 |     x = 6;
  |     ^^^^^ cannot assign twice to immutable variable
```

* この例は、どのようにコンパイラーがプログラムの中のエラーを見つける手助けをするかを表している
* たとえコンパイラーのエラーが煩わしくても、これらは単に、プログラムでやりたいことが安全に為されていないことを意味している
  * あなたが良くないプログラマーだと言っているのではない！
  * 経験豊富な Rustaceans でも未だにコンパイラーのエラーを出している
* このエラーは、エラーの原因は `不変な変数 x に二度代入はできない` だということを示している
  * 不変な変数 `x` に二番目の値を代入しようとしたため
* 以前に不変な変数として設計された値への変更を試みた時に、コンパイル時エラーが出ることは大切だ
  * まさにその状況はバグを導きかねない
  * もし、一方のコードが、その値は一度も変更されることはないと仮定して処理をし、もう一方がその値を変更したならば、最初のほうのコードが設計されたように動かないことがあり得る
  * この手のバグの原因は、それが起こった後に追跡するのが困難になり得る
    * 特に、そのもう一方のコードが *時々* 値を変更する時
* Rust では、値が変更されないと宣言したとき、コンパイラーはそれが本当に変更されないことを保証する
* これは、コードを読み書きしている時、どこで、どのようにして値が変更され得るかを追跡する必要はないことを意味している
  * すなわち、コードの内容を通して推論することがより簡単になる
* しかし、可変性はとても便利なことがある
* 2 章でやったように、変数は単にデフォルトで不変なだけなので、変数名の前に `mut` を加えることで可変にできる
  * 値が変更を許容するのに加えて、`mut` は、他の部分のコードがこの変数の値を変更するであろうという意図を、コードを読む人に伝える
* 例として、以下のように *src/main.rs* を変更しよう

ファイル名: src/main.rs

```rust
fn main() {
  let mut x = 5;
  println!("The value of x is: {}", x);
  x = 6;
  println!("The value of x is: {}", x);
}
```

* このプログラムを実行すると、以下の出力が出る

```bash
$ cargo run
   Compiling variables v0.1.0 (file:///projects/variables)
    Finished dev [unoptimized + debuginfo] target(s) in 0.30 secs
     Running `target/debug/variables`
The value of x is: 5
The value of x is: 6
```

* `mut` が使われた時、`x` が束縛する値は `5` から `6` へ変更されることが許容される
* いくつかの場合では、変数を可変にしたいことがあるだろう
  * 可変な変数は、不変な変数しかない場合に比べて、コードを書くのをより便利にする
* バグの防止に加えて、考慮すべき複数のトレードオフがある
  * 例えば、巨大なデータ構造を使っている場合、コピーして新しく割り当てられたインスタンスを返すより、インスタンスを変更する方が速いかもしれない
  * より小さなデータ構造では、新しいインスタンスを作成し、より関数型プログラミングのスタイルで書く方が、通して考えるのがより簡単かもしれない
    * なので、その明快さのために、より低いパフォーマンスを許容する価値があるかもしれない

### 変数と定数の間の違い

* 変数の値を変更できないことは、他の言語の定数という概念を思い起こすかもしれない
* 不変な変数のように、定数は名前に束縛された値で、変更が許されていない
* しかし、定数と変数の間にはいくつかの違いがある
  * まず、定数に `mut` を使うことは許されていない
    * 定数は単にデフォルトで不変というわけではなく、常に不変
  * 定数は `let` の代わりに `const` キーワードで宣言し、値の型は注釈付けしなければならない
    * 次の「データ型」の節で型と型注釈を網羅しようとしているので、その詳細については今は心配しなくていい
    * 常に型に注釈付けしなければならないことだけを知っておけばよい
  * 定数はどのスコープでも宣言できる
    * グローバルスコープも含む
    * 多くのほかの部分のコードが知る必要がある値を便利にすることができる
  * 最後の違いは、定数は定数エクスプレッションからのみ設定できる
    * 関数呼び出しの結果や、実行時にのみ計算できる値は使えない
* 定数の名前が `MAX_POINTS` で、その値が 100,000 である、定数の宣言の例がこれである
  * Rust の定数の命名習慣は、すべて大文字で単語間はアンダースコア
  * 読みやすさの改善のために、数字のリテラルにアンダースコアを挿入できる

```rust
const MAX_POINTS: u32 = 100_000;
```

* 定数はプログラムの実行時間全体で有効
  * 宣言されたスコープ内で有効
  * 複数の部分で知られなければならない値のスコープの選択は、あなたのアプリケーションのドメインにおいて便利になる
    * ゲームのプレイヤーが稼げるポイントの最大値
    * 光の速度
* プログラムの至る所で使われるハードコードされた値に、定数として名前を付けるのは、そのコードの将来のメンテナーにその値の意味を伝えるのに役立つ
  * もしハードコードされた値が将来更新する必要があるなら、変更が必要な部分が一か所だけになって助かる

### 隠蔽

* 2 章でみたように、前の変数と同じ名前で新しい変数を宣言できて、新しい変数は前の変数を隠蔽する
* Rustaceans はそれを、最初の値は二番目の値で覆い隠されたという
  * その変数が使われた時、二番目の値が現れることを意味する
* 以下のように、同じ変数名と `let` キーワードの使用を繰り返すことで変数を隠蔽できる

ファイル名: src/main.rs

```rust
fn main() {
  let x = 5;

  let x = x + 1;

  let x = x * 2;

  println!("The value of x is: {}", x);
}
```

* このプログラムは最初に、値 `5` を `x` に束縛する
* そして、元の値をとってきて `1` を加える `let x =` によって `x` を隠蔽するので、`x` の値は `6` になる
* 三番目の `let` ステートメントも `x` を隠蔽し、前の値に `2` を掛けて、最終的に `x` の値を `12` にする
* このプログラムを実行すると、以下のように出力する

```bash
$ cargo run
   Compiling variables v0.1.0 (file:///projects/variables)
    Finished dev [unoptimized + debuginfo] target(s) in 0.31 secs
     Running `target/debug/variables`
The value of x is: 12
```

* 隠蔽は変数を `mut` としてマーキングするのとは違う
  * もし意図せず `let` キーワードを使わずにこの変数に再代入しようとするとコンパイラーが出るため
* `let` を使うことで、変数にちょっとした変換をしつつ、その変換後も変数を不変のままにすることができる
* 他の `mut` と隠蔽の間の違いは、`let` を再使用する時、実質新しい変数を作成するため、型を変更しつつ同じ名前を再利用できる
  * 例えば、スペース文字を入力させることで、プログラムがユーザーにテキストの間にいくつスペースが欲しいか尋ねつつ、その入力を本当は数として保存したいとする

```rust
let spaces = "   ";
let spaces = spaces.len();
```

* 最初の `spaces` 変数は文字列型で、二番目の `spaces` 変数は最初の変数と同じ名前を持つようになった新しい変数となって数値型となるため、この構造は許される
* すなわち、隠蔽は `spaces_str` や `spaces_num` のような違った名前を使わずに済むようにしてくれて、代わりにより単純な `spaces` という名前を再使用できる
* しかし、もし以下のように `mut` をこれに使おうとすると、コンパイルエラーが出る

```rust
let mut spaces = "   ";
spaces = spaces.len();
```

* このエラーは変数の型を変更することは許されていないと言っている

```bash
error[E0308]: mismatched types
 --> src/main.rs:3:14
  |
3 |     spaces = spaces.len();
  |              ^^^^^^^^^^^^ expected &str, found usize
  |
  = note: expected type `&str`
             found type `usize`
```

* 変数がどのように働くかを見てきたので、変数が持てるより多くの型を見ていこう

## データ型

* Rust においてすべての値は必ずデータ型に属している
  * それは Rust にどんな種類のデータが指定されているかを知らせるので、そのデータでどのように処理すればいいかが分かる
* これからデータ型の二つの部分集合を見ていく
  * スカラー型と複合型
* Rust は静的型付け言語で、それは全ての変数の型がコンパイル時に明らかでなければならないことを意味しているのを心に留めておくこと
* コンパイラーは通常、値やそれをどう使うかに基づいて使いたい型を推論する
  * 2 章で `String` を `parse` を使って数値型に変換する時のように、多くの型があり得る場合、以下のように型注釈を加えなければならない

```rust
let guess: u32 = "42".parse().expect("Not a number!");
```

* もしここで型注釈を加えないと、Rust は以下のようなエラーメッセージを表示し、それはコンパイラーが私達からより多くの、私達が使いたい型の情報が必要だということを意味している

```bash
error[E0282]: type annotations needed
 --> src/main.rs:2:9
  |
2 |     let guess = "42".parse().expect("Not a number!");
  |         ^^^^^
  |         |
  |         cannot infer type for `_`
  |         consider giving `guess` a type
```

* 他のデータ型に対する違った型注釈をこれから見ていく

### スカラー型

* スカラー型は単一の値を表す
* Rust は四つの主要なスカラー型を持っている
  * 整数
  * 浮動小数点数
  * ブーリアン
  * 文字
* 他の言語で見たことがあるかもしれない
* Rust でそれらがどのように働くかを見ていこう

#### 整数型

* 整数は分数の部分がない数
* 2 章で一つ整数型 `u32` を使った
  * この型の宣言は、その値が 32 bit 分のスペースを占める符号なしの整数であるべきであることを示している
  * 符号付整数は、`u` の代わりに `i` で始まる
* Table 3-1 は Rust に組み込まれている整数型を示している
* 符号ありと符号なしの列それぞれが、整数値の型を宣言するのに使うことができる

Table 3-1: Rust の整数型

| ビット長 | 符号あり | 符号なし |
| ------- | ------- | ------- |
| 8-bit   | `i8`    | `u8`    |
| 16-bit  | `i16`   | `u16`   |
| 32-bit  | `i32`   | `u32`   |
| 64-bit  | `i64`   | `u64`   |
| 128-bit | `i128`  | `u128`  |
| arch    | `isize` | `usize` |

* 異なる整数型それぞれが、符号ありと符号なしのどちらかになることができ、明示的なサイズを持っている
* 符号ありと符号なしは、その数が正か負のどちらかになれるかどうかを表している
  * 言い換えると、以下のようになるかどうかを表している
    * その数は符号を持つ必要がある (符号あり)
    * その数は正だけであり、符号なしで表すことができる (符号なし)
  * それは、紙に数を書くことのようだ
    * 符号を考慮すべき時は、数は + または - とともに現れる
    * しかし、その数が正であると安全に仮定できるときは、符号なしで現れる
* 符号ありの数は 2 の補数の表現を使って保存される
  * もしこれが何なのか定かではないなら、オンラインで検索できる
  * この説明はこの本のスコープ外
* 異なる符号ありの整数型それぞれが -(2^(n - 1)) 以上 2^(n - 1) 以下の数を保存できる
  * n はビット数
  * なので、`i8` は -(2^7) から 2^7 - 1 までの数を保存できる
    * -(2^7) から 2^7 - 1 までは、-128 から 127 までと等価
* 異なる符号なしの整数型はそれぞれが 0 から 2^n - 1 まで保存できる
  * なので、`u8` は 0 から 2^8 - 1 まで保存できる
    * 0 から 255 まで
* 加えて、`isize` と `usize` 型は、プログラムが実行されるコンピューターの種類に依存する
  * 64-bit アーキテクチャーなら 64 ビット
  * 32-bit アーキテクチャーなら 32 ビット
* 整数リテラルを Table 3-2 に示すような形式で書くことができる
  * バイトリテラルを除くすべての数値リテラルで `57u8` のような型サフィックスをおけることや、`1_000` のように `_` を視覚的セパレーターとしておけることを覚えておこう

Table 3-2: Rust の整数リテラル

| 数値リテラル | 例        |
| ----------- | -------- |
| 10 進数      | `98_222` |
| 16 進数      | `0xff`   |
| 8 進数       | `0o77`   |
| 2 進数       | `0b1111_0000` |
| バイト (`u8` のみ) | `b'A'` |

* それで、どの整数型を使うかを知るにはどうすればよいか？
  * もし定かではないなら、一般的に Rust のデフォルトがよい選択になる
  * 整数型のデフォルトは `i32`
    * 64-bit のシステムでさえ、この型は一般的に最速
  * `isize` や `usize` を使う主要な状況は、何らかのコレクションをインデックス付けする時

##### 整数のオーバーフロー

* `u8` があって、それは `0` から `255` までの値を保持できるとしよう
* もしそれを `256` に変更しようとするとどうなる？
* これは「整数オーバーフロー」と呼ばれ、Rust はこの振る舞いに関していくつかの興味深いルールを持っている
  * デバッグモードでコンパイルしているとき、Rust はこの種の問題をチェックし、プログラムの _panic_ を引き起こすだろう
    * _panic_ は、プログラムがエラーで終了するときに Rust が使う用語
    * _panic_ については 9 章でもっと話す
  * リリースビルドでは、Rust はオーバーフローをチェックせず、代わりに「2 の補数ラッピング」と呼ばれることを行う
    * かいつまんで言うと、`256` は `0` になり、`257` は `1` になる
  * たとえその挙動が起こるのだとしても、オーバーフローを頼りにするのはエラーだと考えられる
    * もしこの挙動を明示的に欲しいなら、それを明示的に提供する標準ライブラリーの型 `Wrapping` がある

#### 浮動小数点型

* Rust はまた、小数点を持つ浮動小数点数のための二つのプリミティブ型を持っている
  * Rust の浮動小数点型は `f32` と `f64` で、サイズはそれぞれ 32 ビットと 64 ビット
  * デフォルトの型は `f64`
    * なぜなら、今どきの CPU は `f32` と同じくらいのスピードが出て、より精度が高いため
* 以下は実際に浮動小数点数を示す例

ファイル名: src/main.rs

```rust
fn main() {
  let x = 2.0; // f64

  let y: f32 = 3.0; // f32
}
```

* 浮動小数点数は IEEE-754 標準によって表現される
* `f32` は単精度、`f64` は倍精度

#### 数値演算

* Rust は、あなたがすべての数値型に期待する基本的な数学的演算をサポートする
  * 加算
  * 減算
  * 乗算
  * 除算
  * 剰余
* 以下のコードは、`let` ステートメントでそれぞれの演算をどのように使えるかを示している

ファイル名: src/main.rs

```rust
fn main() {
  // 加算
  let sum = 5 + 10;

  // 減算
  let difference = 95.5 - 4.3;

  // 乗算
  let product = 4 * 30;

  // 除算
  let quotient = 56.7 / 32.2;

  // 剰余
  let remainder = 43 % 5;
}
```

* これらのステートメント中のそれぞれの式は数学的演算子を使っていて、変数に束縛される単一の値を算出する
* 付録 B は Rust が提供する全ての演算子のリストを含んでいる

#### ブーリアン型

* 他のほとんどのプログラミング言語のように、Rust のブーリアン型は二つの値を取りうる
  * `true`
  * `false`
* Rust のブーリアン型は `bool` を使って指定する
* 例えば以下のようになる

ファイル名: src/main.rs

```rust
fn main() {
  let t = true;

  let f: bool = false; // 明示的な型注釈
}
```

* ブーリアン値の主な使い道は、`if` 式のような条件分岐
* 「制御フロー」の節で Rust の `if` 式がどのように動くかを網羅する
* ブーリアンのサイズは 1 バイト

#### 文字型

* ここまで数値だけを扱ってきたが、 Rust は文字もサポートする
* Rust の `char` 型は言語の最も原始的なアルファベットの型で、以下のコードは使い方の一つを示している
  * 以下のことを覚えておくこと
    * `char` リテラルは `'` で指定される
    * 対して、文字列リテラルは `"` を使う

ファイル名: src/main.rs

```rust
fn main() {
  let c = 'z';
  let z = 'ℤ';
  let heart_eyed_cat = '😻';
}
```

* Rust の `char` 型はユニコードスカラー値を表現する
  * それは、ASCII よりもとても多くの文字を表現できることを意味する
  * 以下のすべての文字が Rust で有効
    * アクセントされた文字
    * 中国語
    * 日本語
    * 韓国語
    * ゼロ幅スペース
  * ユニコードスカラー値は `U+0000` 以上 `U+D7FF` 以下、`U+E000` 以上 `U+10FFFF` 以下
  * しかしながら「文字」は本当のところユニコードの概念ではない
    * なので、「文字」が何なのかという人間の直感は、Rust の `char` が何なのかということと噛み合わないかもしれない
    * このことについて、8 章の「文字列」で詳しく議論する

### 複合型

* 複合型は複数の値を一つの型にまとめることができる
* Rust は二つのプリミティブ複合型を持っている
  * タプル
  * 配列

#### タプル型

* タプルは、様々な型の様々な値を一つの複合型にまとめる一般的な方法
* タプルは固定長
  * 一度宣言されると、サイズの伸長や収縮はできない
* タプルは括弧内にコンマ区切りの値のリストを書くことで作成する
* タプル内のそれぞれの位置は型を持ち、タプル内の異なる位置の値の型は同じである必要はない
* 以下の例では、省略可能な型注釈を追加している

ファイル名: src/main.rs

```rust
fn main() {
  let tup: (i32, f64, u8) = (500, 6.4, 1);
}
```

* 変数 `tup` はタプル全体を束縛している
  * なぜなら、タプルは単一の複合要素として考えられているから
* タプルからそれぞれの値を得るには、以下のようにパターンマッチングを使ってタプルの値を分解することができる

Filename: src/main.rs

```rust
fn main() {
  let tup = (500, 6.4, 1);

  let (x, y, z) = tup;

  println!("The value of y is : {}", y);
}
```

* このプログラムは最初にタプルを作成し、変数 `tup` に束縛している
* それから、`let` というパターンを使って三つの分かれた変数 `x`, `y`, `z` に変換している
* これは「分解」と呼ばれる
  * 単一のタプルを三つの部分に分けているため
* 最後に、そのプログラムは `y` の値(`6.4`)を表示する
* パターンマッチングを通した分解に加えて、ピリオド(`.`)とそれに続く、欲しい値のインデックスによって直接タプルの要素にアクセスできる
* 例えば以下の通り

ファイル名: src/main.rs

```rust
fn main() {
  let x: (i32, f64, u8) = (500, 6.4, 1);

  let five_hundred = x.0;

  let six_point_four = x.1;

  let one = x.2;
}
```

* このプログラムはタプル `x` を作成し、インデックスを使ってそれらの要素に対する新しい変数を作成している
* ほとんどのプログラミング言語と同じように、タプルの最初のインデックスは 0

#### 配列型

* もう一つの、複数の値のコレクションを持つ方法は、配列を使うこと
* タプルとは違って、配列の全ての要素は同じ型を持たなくてはならない
* Rust の配列はほかのいくつかの言語の配列と違っている
  * Rust の配列はタプルのように固定長だから
* Rust では、配列に入る値は角括弧の中にコンマ区切りのリストとして書かれる

ファイル名: src/main.rs

```rust
fn main() {
  let a = [1, 2, 3, 4, 5];
}
```

* 配列は以下のようなときに便利
  * ヒープ領域ではなくスタック領域にデータを割り当てたいとき
    * スタック領域とヒープ領域については 4 章でもっと議論する
  * 常に一定の数の要素を持っていることを確信できるようにしたいとき
* あいにく配列はベクター型のように柔軟ではない
  * ベクターは、サイズが伸縮可能な、標準ライブラリーによって提供される、配列と似たようなコレクション型
  * ベクターは 8 章でより詳しく議論する
* もし、配列とベクターのどちらを使うべきか定かではないなら、おそらくベクターを使うべきだ
* ベクターより配列を使いたいかもしれない時の例は、プログラムで年月日の月の名前を知る必要があるとき
  * そのようなプログラムでは、月を追加したり削除したりするようなことはほぼなさそう
  * そういうわけで、常に 12 個の要素を含むとわかっているので、配列を使うことができる

```rust
let months = ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"];
```

* 配列は興味深い型を持っている
  * `[type; number]`

```rust
let a: [i32; 5] = [1, 2, 3, 4, 5];
```

* 最初に角括弧がある
  * 配列を作成する構文のようだ
* その中で、セミコロンで区切られた二つの部分の情報がある
  * 最初は配列のそれぞれの要素の型
    * 全ての要素は同じ型を持つので、一度書くだけでいい
  * セミコロンの後で、配列の長さを示す数がある
    * 配列は固定長なので、配列の要素が変更されたとしても伸縮できず、この数は常に同じになる

##### 配列の要素へのアクセス

* 配列はスタック領域に割り当てられる、メモリ上の単一のデータの塊
* 以下のようにして、インデックスを使って配列の要素にアクセスできる

ファイル名: src/main.rs

```rust
fn main() {
  let a = [1, 2, 3, 4, 5];

  let first = a[0];
  let second = a[1];
}
```

* この例では、`first` と名付けられた変数は値 `1` を得る
  * それは配列中のインデックス `[0]` にある値だから
* `second` と名付けられた変数は、配列のインデックス `[1]` から値 `2` を得る

##### 無効な配列要素へのアクセス

* 配列の最後の要素を過ぎた要素にアクセスしようとしたとすると、何が起こるだろうか？
* 上記の例を以下のコードに変更するとしよう
  * これはコンパイルは通るが、実行時にエラーが発生して終了するだろう

ファイル名: src/main.rs

```rust
fn main() {
  let a = [1, 2, 3, 4, 5];
  let index = 10;

  let element = a[index];

  println!("The value of element is: {}", element);
}
```

* このコードを `cargo run` を使って実行すると、以下のような結果を生成する

```bash
$ cargo run
   Compiling arrays v0.1.0 (file:///projects/arrays)
    Finished dev [unoptimized + debuginfo] target(s) in 0.31 secs
     Running `target/debug/arrays`
thread '<main>' panicked at 'index out of bounds: the len is 5 but the index is
 10', src/main.rs:6
note: Run with `RUST_BACKTRACE=1` for a backtrace.
```

* コンパイルは何もエラーを生成しないが、プログラムは実行時エラーという結果となり、成功裏に終了しない
* インデックスを使って要素へのアクセスを試みるとき、Rust は指定したインデックスが配列の長さより小さいことをチェックする
  * もしインデックスが配列の長さより大きい場合、Rust はパニックするだろう
* これは Rust の安全性原則の働きの最初の例
  * 多くの低レベル言語では、この種のチェックは為されず、誤ったインデックスを渡したときには無効なメモリー領域へアクセスされ得る
  * Rust は、無効なメモリーアクセスと実行の継続をする代わりに、即座に実行を終了することで、この種のエラーからあなたを守ってくれる
  * 9 章でRust のエラー処理をもっと議論する

## 関数

* 関数は Rust のコードの隅々までいきわたっている
* 既に言語で最も重要な関数の一つ、`main` 関数を見ている
  * `main` 関数は多くのプログラムの開始点
* `fn` キーワードもまた見ている
  * 新しい関数を宣言する
* Rust のコードは、関数や変数の名前の習慣的なスタイルとして、スネークケースを使っている
  * スネークケースでは、すべての文字が小文字で、アンダースコアが単語を区切る
* 以下が関数の定義を含んだプログラムの例だ

ファイル名: src/main.rs

```rust
fn main() {
  println!("Hello, world!");

  another_function();
}

fn another_function() {
  println!("Another function.");
}
```

* Rust での関数の定義は `fn` で始まり、関数名の後に括弧の組を持つ
  * 波括弧はコンパイラーに、関数の始まりと終わりがどこかを教える
  * 名前とそれに続く括弧の組を入力して定義された関数はどれでも呼び出すことができる
* `another_function` はプログラムで定義されているので、`main` 関数の中から呼び出すことができる
  * ソースコードの `main` 関数の後で `another_function` を定義したことを覚えておくこと
    * `main` 関数の前で定義することもできる
  * Rust は関数がどこで定義されたかを気にせず、どこかで定義されていることだけを気にする
* _functions_ と名付けられた新しいバイナリプロジェクトを始めて、関数をもっと探求しよう
  * _src/main.rs_ に `another_function` の例を置いて実行しよう

```bash
$ cargo run
   Compiling functions v0.1.0 (file:///projects/functions)
    Finished dev [unoptimized + debuginfo] target(s) in 0.28 secs
     Running `target/debug/functions`
Hello, world!
Another function.
```

* その一連の行は `main` 関数で現れた順で実行される
  * 始めに「Hello, world!」メッセージが出力され、それから `another_function` が呼ばれてそのメッセージを出力する

### 関数パラメーター

* 関数はまた、パラメーターを持つように定義することができる
  * パラメーターは、関数のシグネチャーの一部をなす特別な変数
* 関数がパラメーターを持つとき、それらのパラメーターに対して実際の値を提供することができる
  * 技術的には、その実際の値は _arguments_ と呼ばれるが、普段の会話では人々は _parameter_ と _argument_ を相互に入れ替えて使いがち
    * 関数のパラメーターや、関数呼び出し時の実際の値を _parameter_ や _argument_ と言ったりする
* 以下の書き直された版の `another_function` は Rust でパラメーターがどのように見えるかを示している

ファイル名: src/main.rs

```rust
fn main() {
  another_function(5);
}

fn another_function(x: i32) {
  println!("The value of x is: {}", x);
}
```

* このプログラムを実行してみよう
* 以下のような出力を得られるべきだ

```bash
$ cargo run
   Compiling functions v0.1.0 (file:///projects/functions)
    Finished dev [unoptimized + debuginfo] target(s) in 1.21 secs
     Running `target/debug/functions`
The value of x is: 5
```

* `another_function` の宣言は `x` と名付けられた一つのパラメーターを持つ
* `x` の型は `i32` として指定されている
* `another_function` に `5` が渡された時、`println!` マクロは書式文字列の中の波括弧の組のところに `5` を置く
* 関数のシグネチャーでは、それぞれのパラメーターの型を宣言しなければならない
* これは Rust の設計におけるよく考えられた決断だ
  * 関数の宣言で型注釈が必要とされることは、コードの他のところで、その関数呼び出しが何を意味しているかをコンパイラーに対して明らかにする必要がないことを意味する
* 関数に複数のパラメーターを持たせたいとき、以下のようにパラメーターの宣言をコンマで区切る

ファイル名: src/main.rs

```rust
fn main() {
  another_function(5, 6);
}

fn another_function(x: i32, y: i32) {
  println!("The value of x is: {}", x);
  println!("The value of y is: {}", y);
}
```

* この例は二つのパラメーターを伴った関数を作成している
  * どちらも `i32` 型
* その関数はそれからパラメーターの両方の値を出力する
* 関数のパラメーターは、ちょうどこの例でそうなったように、パラメーターをすべて同じにする必要はないことを覚えておくこと
* このコードを実行してみよう
  * 現在の _functions_ プロジェクトの _src/main.rs_ ファイルを上記の例で置き換えて、`cargo run` を使って実行しよう

```bash
$ cargo run
   Compiling functions v0.1.0 (file:///projects/functions)
    Finished dev [unoptimized + debuginfo] target(s) in 0.31 secs
     Running `target/debug/functions`
The value of x is: 5
The value of y is: 6
```

* `x` の値を `5`、`y` の値を `6` として渡したので、二つの文字列はこれらの値で出力される

### 文 (Statements) や式 (Expressions) を含んだ関数

* 関数の本体は一連の文と、必須ではない終端の式で構成されている
* いままで終端の式を持たない関数だけを見てきたが、文の一部としての式を見ている
  * Rust は式ベースの言語なので、これは理解するための重要な区別だ
  * ほかの言語は同じ区別を持たないので、文や式が何であるかや、これらの違いがどのように関数の本体に影響するかを見ていこう
* 実際にはすでに文や式を使っている
  * 文は何らかのアクションを実行する命令で、値を返さない
  * 式は結果の値を評価する
* いくつかの例を見ていこう
  * `let` キーワードで変数を作成して値を代入するのは文だ
  * Listing 3-1 では `let y = 6;` が文である

ファイル名: src/main.rs

```rust
fn main() {
  let y = 6;
}
```

Listing 3-1: 一つの文を含んだ `main` 関数の宣言

* 関数の定義もまた文
  * 上記の例全体が文それ自身である
* 文は値を返さない
  * したがって、以下の例のように `let` 文をもう一つの変数へ代入することはできない
    * そうしようとするとコンパイルエラーとなる

ファイル名: src/main.rs

```rust
fn main() {
  let x = (let y = 6);
}
```

* このプログラムを実行したとき、以下のようなエラーが出るだろう

```bash
$ cargo run
   Compiling functions v0.1.0 (file:///projects/functions)
error: expected expression, found statement (`let`)
 --> src/main.rs:2:14
  |
2 |     let x = (let y = 6);
  |              ^^^
  |
  = note: variable declaration using `let` is a statement
```

* `let y = 6` 文は値を返さないので、`x` に束縛するものが何もない
  * これは代入自身が代入された値を返す C や Ruby のような他の言語とは違う
  * それらの言語では `x = y = 6` と書くことができ、`x`, `y` 両方が値 `6` を持つ
    * Rust ではそうではない
* 式は何かを評価し、あなたが書く Rust のコードの残りのほとんどを構成している
* `5 + 6` のような、`11` という値へと評価する単純な数学の演算の式を考えてみよう
  * 式は文の一部になることができる
    * Listing 3-1 では、`let y = 6` 文の `6` は、値 `6` へと評価される式である
  * 関数呼び出しは式である
  * マクロ呼び出しは式である
  * 新しいスコープを作るブロック `{}` は式である
    * 例えば以下の通り

ファイル名: src/main.rs

```rust
fn main() {
  let x = 5;

  let y = {
    let x = 3;
    x + 1
  };

  println!("The value of y is: {}", y);
}
```

この式:

```rust
{
  let x = 3;
  x + 1
}
```

はこの場合、値 `4` へと評価する式である

* その値は `let` 文の一部として `y` に束縛される
* 最後のセミコロンなしの行 `x + 1` を覚えておくこと
  * 今まであなたが見てきたほとんどの行のようではない
* 式は最後のセミコロンを含まない
  * もし式の最後にセミコロンを加えると、それは文となり、値を返さなくなる
  * 次の関数の戻り値や式を探求する時、これを心に留めておくこと

### 戻り値を伴った関数

* 関数は、それを呼び出したコードへと値を返すことができる
  * 戻り値に名前は付けないが、それらの型は矢印 `->` の後で宣言する
  * Rust では、関数の戻り値は、関数の本体の最後の式の値と同類である
  * キーワード `return` を使って値を指定することで、関数から早期に値を返すことができるが、ほとんどの関数が暗黙的に最後の式を返す
* 以下は値を返す関数の例だ

ファイル名: src/main.rs

```rust
fn five() -> i32 {
  5
}

fn main() {
  let x = five();

  println!("The value of x is: {}", x);
}
```

* 関数 `five` では、関数やマクロの呼び出しも、`let` 文さえもなく、ただ数値 `5` それ自身がある
  * それは Rust では完全に有効な関数だ
* 関数の戻り値の型も `-> i32` として指定されていることを覚えておくこと
* このコードを実行してみると、以下のようになるべきだ

```bash
$ cargo run
   Compiling functions v0.1.0 (file:///projects/functions)
    Finished dev [unoptimized + debuginfo] target(s) in 0.30 secs
     Running `target/debug/functions`
The value of x is: 5
```

* `five` の `5` は関数の戻り値で、それが戻り値の型が `i32` である理由だ
  * このことをもっと調べてみよう
  * 二つの重要なところがある
    * `let x = five();` の行が、変数を初期化するために戻り値を使っていることを示している
      * 関数 `five` は `5` を返すので、その行は以下のものと同じになる
        * `let x = 5;`
    * 関数 `five` はパラメーターを持たず、戻り値の型を定義しているが、関数の本体はセミコロンがない単独の `5` である
      * それが返したい値の式だから
* もう一つの例を見てみよう

ファイル名: src/main.rs

```rust
fn main() {
  let x = plus_one(5);

  println!("The value of x is: {}", x);
}

fn plus_one(x: i32) -> i32 {
  x + 1
}
```

* このコードを実行すると `The value of x is: 6` と出力するだろう
* しかし、`x + 1` を含む行の最後にセミコロンを置いて、それを式から文に変えたとすると、エラーが出るだろう

ファイル名: src/main.rs

```rust
fn main() {
  let x = plus_one(5);

  println!("The value of x is: {}", x);
}

fn plus_one(x: i32) -> i32 {
  x + 1;
}
```

* このコードをコンパイルすると以下のようなエラーが生成される

```bash
error[E0308]: mismatched types
 --> src/main.rs:7:28
  |
7 |   fn plus_one(x: i32) -> i32 {
  |  ____________________________^
8 | |     x + 1;
  | |          - help: consider removing this semicolon
9 | | }
  | |_^ expected i32, found ()
  |
  = note: expected type `i32`
             found type `()`
```

* 主なエラーメッセージ「型の不整合」はこのコードの問題の核心を明らかにしている
  * `plus_one` 関数の定義は `i32` を返すと言っているが、文は値へ評価されない
    * 文が値を返さないことは、空のタプル `()` で表現される
  * したがって、何も返されず、関数の定義と食い違い、エラーという結果となる
  * この出力では、Rust は、この問題を修正する助けになり得るメッセージを提供する
    * セミコロンを除去することを提案しており、それはエラーを解消するだろう

## コメント

* すべてのプログラマーは彼らのコードを理解しやすくなるように努力しているが、時々追加の説明が必要とされる
* この場合、プログラマーはソースコードにノートやコメントを残す
  * コメントはコンパイラーに無視されるが、ソースコードを読む人々はそれを便利だと思うかもしれない
* 以下は単純なコメントだ

```rust
// hello, world
```

* Rust では、コメントは二つのスラッシュで始まらなくてはならず、行の終わりまで続く
* 一行を超えるコメントでは、以下のようにそれぞれの行に `//` を含む必要がある

```rust
// So we’re doing something complicated here, long enough that we need
// multiple lines of comments to do it! Whew! Hopefully, this comment will
// explain what’s going on.
```

* コメントはまた、コードを含む行の最後に置くこともできる

ファイル名: src/main.rs

```rust
fn main() {
  let lucky_number = 7; // I'm feeling lucky today
}
```

* しかし、コード行の上にそれを注釈するコメントを置く書式のほうを良く目にするだろう

ファイル名: src/main.rs

```rust
fn main() {
  // I'm feeling lucky today
  let lucky_number = 7;
}
```

* Rust はまた、ドキュメンテーションコメントという、もう一つの種類のコメントを持っている
  * 14 章で議論する
