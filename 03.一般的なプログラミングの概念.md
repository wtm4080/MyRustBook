# 一般的なプログラミングの概念

* この章では、ほぼ全てのプログラミング言語で現れる概念と、Rust でそれらがどのように動くかを網羅する
  * 多くのプログラミング言語は中核部分が共通している
  * この章で現れる概念で Rust 特有のものはないが、それらを Rust の文脈で述べて、それらの概念の周りにある習慣を説明する
* 特に、以下のものを学ぶ
  * 変数
  * 基本的な型
  * 関数
  * コメント
  * 制御フロー
* これらの基礎は全ての Rust プログラムにあり、早期にそれらを学ぶことは、出発点の強固な中核を得ることになるだろう

---

## キーワード

* Rust には一連の *keyword* がある
  * 他の言語のように、言語でのみ使用されるように予約されている
* これらのキーワードは、変数や関数の名前として使えないことを心に留めておかなければならない
* 殆どのキーワードは特別な意味を持っていて、Rust のプログラムで様々なことをこなすために使う
  * いくつかは現在機能が割り当てられていないが、 Rust に将来追加される機能のために予約されている
* キーワードの一覧は付録 A で見つかる

---

## 変数と可変性

* 2 章で述べたように、デフォルトで変数は不変
  * これは数多くある、並列性の利点を安全で簡単に享受するための Rust の後押しの一つ
* しかし、変数を可変とする選択肢も依然としてある
* Rust が、なぜ、どのようにして普遍性を好むように奨励するのか、そして、なぜ時々それを覆したくなることがあるかを見ていこう
* 変数が不変の時、一度値が名前に束縛されたら、その値を変更することができない
* これを表すために *variables* と呼ばれる新しいプロジェクトを `cargo new variables` を用いて *projects* ディレクトリの中に生成しよう
* そして、新しい *variables* ディレクトリの中で *src/main.rs* を開いて、以下のコードで置き換える
  * まだコンパイルできない

ファイル名: src/main.rs

```rust
fn main() {
  let x = 5;
  println!("The value of x is: {}", x);
  x = 6;
  println!("The value of x is :{}", x);
}
```

* 保存して `cargo run` でプログラムを実行する
* エラーメッセージを受け取るはずで、このような出力が表示される

```bash
error[E0384]: cannot assign twice to immutable variable `x`
 --> src/main.rs:4:5
  |
2 |     let x = 5;
  |         - first assignment to `x`
3 |     println!("The value of x is: {}", x);
4 |     x = 6;
  |     ^^^^^ cannot assign twice to immutable variable
```

* この例は、どのようにコンパイラーがプログラムの中のエラーを見つける手助けをするかを表している
* たとえコンパイラーのエラーが煩わしくても、これらは単に、プログラムでやりたいことが安全に為されていないことを意味している
  * あなたが良くないプログラマーだと言っているのではない！
  * 経験豊富な Rustaceans でも未だにコンパイラーのエラーを出している
* このエラーは、エラーの原因は `不変な変数 x に二度代入はできない` だということを示している
  * 不変な変数 `x` に二番目の値を代入しようとしたため
* 以前に不変な変数として設計された値への変更を試みた時に、コンパイル時エラーが出ることは大切だ
  * まさにその状況はバグを導きかねない
  * もし、一方のコードが、その値は一度も変更されることはないと仮定して処理をし、もう一方がその値を変更したならば、最初のほうのコードが設計されたように動かないことがあり得る
  * この手のバグの原因は、それが起こった後に追跡するのが困難になり得る
    * 特に、そのもう一方のコードが *時々* 値を変更する時
* Rust では、値が変更されないと宣言したとき、コンパイラーはそれが本当に変更されないことを保証する
* これは、コードを読み書きしている時、どこで、どのようにして値が変更され得るかを追跡する必要はないことを意味している
  * すなわち、コードの内容を通して推論することがより簡単になる
* しかし、可変性はとても便利なことがある
* 2 章でやったように、変数は単にデフォルトで不変なだけなので、変数名の前に `mut` を加えることで可変にできる
  * 値が変更を許容するのに加えて、`mut` は、他の部分のコードがこの変数の値を変更するであろうという意図を、コードを読む人に伝える
* 例として、以下のように *src/main.rs* を変更しよう

ファイル名: src/main.rs

```rust
fn main() {
  let mut x = 5;
  println!("The value of x is: {}", x);
  x = 6;
  println!("The value of x is: {}", x);
}
```

* このプログラムを実行すると、以下の出力が出る

```bash
$ cargo run
   Compiling variables v0.1.0 (file:///projects/variables)
    Finished dev [unoptimized + debuginfo] target(s) in 0.30 secs
     Running `target/debug/variables`
The value of x is: 5
The value of x is: 6
```

* `mut` が使われた時、`x` が束縛する値は `5` から `6` へ変更されることが許容される
* いくつかの場合では、変数を可変にしたいことがあるだろう
  * 可変な変数は、不変な変数しかない場合に比べて、コードを書くのをより便利にする
* バグの防止に加えて、考慮すべき複数のトレードオフがある
  * 例えば、巨大なデータ構造を使っている場合、コピーして新しく割り当てられたインスタンスを返すより、インスタンスを変更する方が速いかもしれない
  * より小さなデータ構造では、新しいインスタンスを作成し、より関数型プログラミングのスタイルで書く方が、通して考えるのがより簡単かもしれない
    * なので、その明快さのために、より低いパフォーマンスを許容する価値があるかもしれない

### 変数と定数の間の違い

* 変数の値を変更できないことは、他の言語の定数という概念を思い起こすかもしれない
* 不変な変数のように、定数は名前に束縛された値で、変更が許されていない
* しかし、定数と変数の間にはいくつかの違いがある
  * まず、定数に `mut` を使うことは許されていない
    * 定数は単にデフォルトで不変というわけではなく、常に不変
  * 定数は `let` の代わりに `const` キーワードで宣言し、値の型は注釈付けしなければならない
    * 次の「データ型」の節で型と型注釈を網羅しようとしているので、その詳細については今は心配しなくていい
    * 常に型に注釈付けしなければならないことだけを知っておけばよい
  * 定数はどのスコープでも宣言できる
    * グローバルスコープも含む
    * 多くのほかの部分のコードが知る必要がある値を便利にすることができる
  * 最後の違いは、定数は定数エクスプレッションからのみ設定できる
    * 関数呼び出しの結果や、実行時にのみ計算できる値は使えない
* 定数の名前が `MAX_POINTS` で、その値が 100,000 である、定数の宣言の例がこれである
  * Rust の定数の命名習慣は、すべて大文字で単語間はアンダースコア
  * 読みやすさの改善のために、数字のリテラルにアンダースコアを挿入できる

```rust
const MAX_POINTS: u32 = 100_000;
```

* 定数はプログラムの実行時間全体で有効
  * 宣言されたスコープ内で有効
  * 複数の部分で知られなければならない値のスコープの選択は、あなたのアプリケーションのドメインにおいて便利になる
    * ゲームのプレイヤーが稼げるポイントの最大値
    * 光の速度
* プログラムの至る所で使われるハードコードされた値に、定数として名前を付けるのは、そのコードの将来のメンテナーにその値の意味を伝えるのに役立つ
  * もしハードコードされた値が将来更新する必要があるなら、変更が必要な部分が一か所だけになって助かる

### 隠蔽

* 2 章でみたように、前の変数と同じ名前で新しい変数を宣言できて、新しい変数は前の変数を隠蔽する
* Rustaceans はそれを、最初の値は二番目の値で覆い隠されたという
  * その変数が使われた時、二番目の値が現れることを意味する
* 以下のように、同じ変数名と `let` キーワードの使用を繰り返すことで変数を隠蔽できる

ファイル名: src/main.rs

```rust
fn main() {
  let x = 5;

  let x = x + 1;

  let x = x * 2;

  println!("The value of x is: {}", x);
}
```

* このプログラムは最初に、値 `5` を `x` に束縛する
* そして、元の値をとってきて `1` を加える `let x =` によって `x` を隠蔽するので、`x` の値は `6` になる
* 三番目の `let` ステートメントも `x` を隠蔽し、前の値に `2` を掛けて、最終的に `x` の値を `12` にする
* このプログラムを実行すると、以下のように出力する

```bash
$ cargo run
   Compiling variables v0.1.0 (file:///projects/variables)
    Finished dev [unoptimized + debuginfo] target(s) in 0.31 secs
     Running `target/debug/variables`
The value of x is: 12
```

* 隠蔽は変数を `mut` としてマーキングするのとは違う
  * もし意図せず `let` キーワードを使わずにこの変数に再代入しようとするとコンパイラーが出るため
* `let` を使うことで、変数にちょっとした変換をしつつ、その変換後も変数を不変のままにすることができる
* 他の `mut` と隠蔽の間の違いは、`let` を再使用する時、実質新しい変数を作成するため、型を変更しつつ同じ名前を再利用できる
  * 例えば、スペース文字を入力させることで、プログラムがユーザーにテキストの間にいくつスペースが欲しいか尋ねつつ、その入力を本当は数として保存したいとする

```rust
let spaces = "   ";
let spaces = spaces.len();
```

* 最初の `spaces` 変数は文字列型で、二番目の `spaces` 変数は最初の変数と同じ名前を持つようになった新しい変数となって数値型となるため、この構造は許される
* すなわち、隠蔽は `spaces_str` や `spaces_num` のような違った名前を使わずに済むようにしてくれて、代わりにより単純な `spaces` という名前を再使用できる
* しかし、もし以下のように `mut` をこれに使おうとすると、コンパイルエラーが出る

```rust
let mut spaces = "   ";
spaces = spaces.len();
```

* このエラーは変数の型を変更することは許されていないと言っている

```bash
error[E0308]: mismatched types
 --> src/main.rs:3:14
  |
3 |     spaces = spaces.len();
  |              ^^^^^^^^^^^^ expected &str, found usize
  |
  = note: expected type `&str`
             found type `usize`
```

* 変数がどのように働くかを見てきたので、変数が持てるより多くの型を見ていこう
