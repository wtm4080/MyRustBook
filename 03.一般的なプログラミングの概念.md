# 一般的なプログラミングの概念

* この章では、ほぼ全てのプログラミング言語で現れる概念と、Rust でそれらがどのように動くかを網羅する
  * 多くのプログラミング言語は中核部分が共通している
  * この章で現れる概念で Rust 特有のものはないが、それらを Rust の文脈で述べて、それらの概念の周りにある習慣を説明する
* 特に、以下のものを学ぶ
  * 変数
  * 基本的な型
  * 関数
  * コメント
  * 制御フロー
* これらの基礎は全ての Rust プログラムにあり、早期にそれらを学ぶことは、出発点の強固な中核を得ることになるだろう

---

## キーワード

* Rust には一連の *keyword* がある
  * 他の言語のように、言語でのみ使用されるように予約されている
* これらのキーワードは、変数や関数の名前として使えないことを心に留めておかなければならない
* 殆どのキーワードは特別な意味を持っていて、Rust のプログラムで様々なことをこなすために使う
  * いくつかは現在機能が割り当てられていないが、 Rust に将来追加される機能のために予約されている
* キーワードの一覧は付録 A で見つかる

---

## 変数と可変性

* 2 章で述べたように、デフォルトで変数は不変
  * これは数多くある、並列性の利点を安全で簡単に享受するための Rust の後押しの一つ
* しかし、変数を可変とする選択肢も依然としてある
* Rust が、なぜ、どのようにして普遍性を好むように奨励するのか、そして、なぜ時々それを覆したくなることがあるかを見ていこう
* 変数が不変の時、一度値が名前に束縛されたら、その値を変更することができない
* これを表すために *variables* と呼ばれる新しいプロジェクトを `cargo new variables` を用いて *projects* ディレクトリの中に生成しよう
* そして、新しい *variables* ディレクトリの中で *src/main.rs* を開いて、以下のコードで置き換える
  * まだコンパイルできない

ファイル名: src/main.rs

```rust
fn main() {
  let x = 5;
  println!("The value of x is: {}", x);
  x = 6;
  println!("The value of x is :{}", x);
}
```

* 保存して `cargo run` でプログラムを実行する
* エラーメッセージを受け取るはずで、このような出力が表示される

```bash
error[E0384]: cannot assign twice to immutable variable `x`
 --> src/main.rs:4:5
  |
2 |     let x = 5;
  |         - first assignment to `x`
3 |     println!("The value of x is: {}", x);
4 |     x = 6;
  |     ^^^^^ cannot assign twice to immutable variable
```

* この例は、どのようにコンパイラーがプログラムの中のエラーを見つける手助けをするかを表している
* たとえコンパイラーのエラーが煩わしくても、これらは単に、プログラムでやりたいことが安全に為されていないことを意味している
  * あなたが良くないプログラマーだと言っているのではない！
  * 経験豊富な Rustaceans でも未だにコンパイラーのエラーを出している
* このエラーは、エラーの原因は `不変な変数 x に二度代入はできない` だということを示している
  * 不変な変数 `x` に二番目の値を代入しようとしたため
* 以前に不変な変数として設計された値への変更を試みた時に、コンパイル時エラーが出ることは大切だ
  * まさにその状況はバグを導きかねない
  * もし、一方のコードが、その値は一度も変更されることはないと仮定して処理をし、もう一方がその値を変更したならば、最初のほうのコードが設計されたように動かないことがあり得る
  * この手のバグの原因は、それが起こった後に追跡するのが困難になり得る
    * 特に、そのもう一方のコードが *時々* 値を変更する時
* Rust では、値が変更されないと宣言したとき、コンパイラーはそれが本当に変更されないことを保証する
* これは、コードを読み書きしている時、どこで、どのようにして値が変更され得るかを追跡する必要はないことを意味している
  * すなわち、コードの内容を通して推論することがより簡単になる
* しかし、可変性はとても便利なことがある
* 2 章でやったように、変数は単にデフォルトで不変なだけなので、変数名の前に `mut` を加えることで可変にできる
  * 値が変更を許容するのに加えて、`mut` は、他の部分のコードがこの変数の値を変更するであろうという意図を、コードを読む人に伝える
* 例として、以下のように *src/main.rs* を変更しよう

ファイル名: src/main.rs

```rust
fn main() {
  let mut x = 5;
  println!("The value of x is: {}", x);
  x = 6;
  println!("The value of x is: {}", x);
}
```

* このプログラムを実行すると、以下の出力が出る

```bash
$ cargo run
   Compiling variables v0.1.0 (file:///projects/variables)
    Finished dev [unoptimized + debuginfo] target(s) in 0.30 secs
     Running `target/debug/variables`
The value of x is: 5
The value of x is: 6
```

* `mut` が使われた時、`x` が束縛する値は `5` から `6` へ変更されることが許容される
* いくつかの場合では、変数を可変にしたいことがあるだろう
  * 可変な変数は、不変な変数しかない場合に比べて、コードを書くのをより便利にする
* バグの防止に加えて、考慮すべき複数のトレードオフがある
  * 例えば、巨大なデータ構造を使っている場合、コピーして新しく割り当てられたインスタンスを返すより、インスタンスを変更する方が速いかもしれない
  * より小さなデータ構造では、新しいインスタンスを作成し、より関数型プログラミングのスタイルで書く方が、通して考えるのがより簡単かもしれない
    * なので、その明快さのために、より低いパフォーマンスを許容する価値があるかもしれない

### 変数と定数の間の違い

* 変数の値を変更できないことは、他の言語の定数という概念を思い起こすかもしれない
* 不変な変数のように、定数は名前に束縛された値で、変更が許されていない
* しかし、定数と変数の間にはいくつかの違いがある
  * まず、定数に `mut` を使うことは許されていない
    * 定数は単にデフォルトで不変というわけではなく、常に不変
  * 定数は `let` の代わりに `const` キーワードで宣言し、値の型は注釈付けしなければならない
    * 次の「データ型」の節で型と型注釈を網羅しようとしているので、その詳細については今は心配しなくていい
    * 常に型に注釈付けしなければならないことだけを知っておけばよい
  * 定数はどのスコープでも宣言できる
    * グローバルスコープも含む
    * 多くのほかの部分のコードが知る必要がある値を便利にすることができる
  * 最後の違いは、定数は定数エクスプレッションからのみ設定できる
    * 関数呼び出しの結果や、実行時にのみ計算できる値は使えない
* 定数の名前が `MAX_POINTS` で、その値が 100,000 である、定数の宣言の例がこれである
  * Rust の定数の命名習慣は、すべて大文字で単語間はアンダースコア
  * 読みやすさの改善のために、数字のリテラルにアンダースコアを挿入できる

```rust
const MAX_POINTS: u32 = 100_000;
```

* 定数はプログラムの実行時間全体で有効
  * 宣言されたスコープ内で有効
  * 複数の部分で知られなければならない値のスコープの選択は、あなたのアプリケーションのドメインにおいて便利になる
    * ゲームのプレイヤーが稼げるポイントの最大値
    * 光の速度
* プログラムの至る所で使われるハードコードされた値に、定数として名前を付けるのは、そのコードの将来のメンテナーにその値の意味を伝えるのに役立つ
  * もしハードコードされた値が将来更新する必要があるなら、変更が必要な部分が一か所だけになって助かる

### 隠蔽

* 2 章でみたように、前の変数と同じ名前で新しい変数を宣言できて、新しい変数は前の変数を隠蔽する
* Rustaceans はそれを、最初の値は二番目の値で覆い隠されたという
  * その変数が使われた時、二番目の値が現れることを意味する
* 以下のように、同じ変数名と `let` キーワードの使用を繰り返すことで変数を隠蔽できる

ファイル名: src/main.rs

```rust
fn main() {
  let x = 5;

  let x = x + 1;

  let x = x * 2;

  println!("The value of x is: {}", x);
}
```

* このプログラムは最初に、値 `5` を `x` に束縛する
* そして、元の値をとってきて `1` を加える `let x =` によって `x` を隠蔽するので、`x` の値は `6` になる
* 三番目の `let` ステートメントも `x` を隠蔽し、前の値に `2` を掛けて、最終的に `x` の値を `12` にする
* このプログラムを実行すると、以下のように出力する

```bash
$ cargo run
   Compiling variables v0.1.0 (file:///projects/variables)
    Finished dev [unoptimized + debuginfo] target(s) in 0.31 secs
     Running `target/debug/variables`
The value of x is: 12
```

* 隠蔽は変数を `mut` としてマーキングするのとは違う
  * もし意図せず `let` キーワードを使わずにこの変数に再代入しようとするとコンパイラーが出るため
* `let` を使うことで、変数にちょっとした変換をしつつ、その変換後も変数を不変のままにすることができる
* 他の `mut` と隠蔽の間の違いは、`let` を再使用する時、実質新しい変数を作成するため、型を変更しつつ同じ名前を再利用できる
  * 例えば、スペース文字を入力させることで、プログラムがユーザーにテキストの間にいくつスペースが欲しいか尋ねつつ、その入力を本当は数として保存したいとする

```rust
let spaces = "   ";
let spaces = spaces.len();
```

* 最初の `spaces` 変数は文字列型で、二番目の `spaces` 変数は最初の変数と同じ名前を持つようになった新しい変数となって数値型となるため、この構造は許される
* すなわち、隠蔽は `spaces_str` や `spaces_num` のような違った名前を使わずに済むようにしてくれて、代わりにより単純な `spaces` という名前を再使用できる
* しかし、もし以下のように `mut` をこれに使おうとすると、コンパイルエラーが出る

```rust
let mut spaces = "   ";
spaces = spaces.len();
```

* このエラーは変数の型を変更することは許されていないと言っている

```bash
error[E0308]: mismatched types
 --> src/main.rs:3:14
  |
3 |     spaces = spaces.len();
  |              ^^^^^^^^^^^^ expected &str, found usize
  |
  = note: expected type `&str`
             found type `usize`
```

* 変数がどのように働くかを見てきたので、変数が持てるより多くの型を見ていこう

## データ型

* Rust においてすべての値は必ずデータ型に属している
  * それは Rust にどんな種類のデータが指定されているかを知らせるので、そのデータでどのように処理すればいいかが分かる
* これからデータ型の二つの部分集合を見ていく
  * スカラー型と複合型
* Rust は静的型付け言語で、それは全ての変数の型がコンパイル時に明らかでなければならないことを意味しているのを心に留めておくこと
* コンパイラーは通常、値やそれをどう使うかに基づいて使いたい型を推論する
  * 2 章で `String` を `parse` を使って数値型に変換する時のように、多くの型があり得る場合、以下のように型注釈を加えなければならない

```rust
let guess: u32 = "42".parse().expect("Not a number!");
```

* もしここで型注釈を加えないと、Rust は以下のようなエラーメッセージを表示し、それはコンパイラーが私達からより多くの、私達が使いたい型の情報が必要だということを意味している

```bash
error[E0282]: type annotations needed
 --> src/main.rs:2:9
  |
2 |     let guess = "42".parse().expect("Not a number!");
  |         ^^^^^
  |         |
  |         cannot infer type for `_`
  |         consider giving `guess` a type
```

* 他のデータ型に対する違った型注釈をこれから見ていく

### スカラー型

* スカラー型は単一の値を表す
* Rust は四つの主要なスカラー型を持っている
  * 整数
  * 浮動小数点数
  * ブーリアン
  * 文字
* 他の言語で見たことがあるかもしれない
* Rust でそれらがどのように働くかを見ていこう

#### 整数型

* 整数は分数の部分がない数
* 2 章で一つ整数型 `u32` を使った
  * この型の宣言は、その値が 32 bit 分のスペースを占める符号なしの整数であるべきであることを示している
  * 符号付整数は、`u` の代わりに `i` で始まる
* Table 3-1 は Rust に組み込まれている整数型を示している
* 符号ありと符号なしの列それぞれが、整数値の型を宣言するのに使うことができる

Table 3-1: Rust の整数型

| ビット長 | 符号あり | 符号なし |
| ------- | ------- | ------- |
| 8-bit   | `i8`    | `u8`    |
| 16-bit  | `i16`   | `u16`   |
| 32-bit  | `i32`   | `u32`   |
| 64-bit  | `i64`   | `u64`   |
| 128-bit | `i128`  | `u128`  |
| arch    | `isize` | `usize` |

* 異なる整数型それぞれが、符号ありと符号なしのどちらかになることができ、明示的なサイズを持っている
* 符号ありと符号なしは、その数が正か負のどちらかになれるかどうかを表している
  * 言い換えると、以下のようになるかどうかを表している
    * その数は符号を持つ必要がある (符号あり)
    * その数は正だけであり、符号なしで表すことができる (符号なし)
  * それは、紙に数を書くことのようだ
    * 符号を考慮すべき時は、数は + または - とともに現れる
    * しかし、その数が正であると安全に仮定できるときは、符号なしで現れる
* 符号ありの数は 2 の補数の表現を使って保存される
  * もしこれが何なのか定かではないなら、オンラインで検索できる
  * この説明はこの本のスコープ外
* 異なる符号ありの整数型それぞれが -(2^(n - 1)) 以上 2^(n - 1) 以下の数を保存できる
  * n はビット数
  * なので、`i8` は -(2^7) から 2^7 - 1 までの数を保存できる
    * -(2^7) から 2^7 - 1 までは、-128 から 127 までと等価
* 異なる符号なしの整数型はそれぞれが 0 から 2^n - 1 まで保存できる
  * なので、`u8` は 0 から 2^8 - 1 まで保存できる
    * 0 から 255 まで
* 加えて、`isize` と `usize` 型は、プログラムが実行されるコンピューターの種類に依存する
  * 64-bit アーキテクチャーなら 64 ビット
  * 32-bit アーキテクチャーなら 32 ビット
* 整数リテラルを Table 3-2 に示すような形式で書くことができる
  * バイトリテラルを除くすべての数値リテラルで `57u8` のような型サフィックスをおけることや、`1_000` のように `_` を視覚的セパレーターとしておけることを覚えておこう

Table 3-2: Rust の整数リテラル

| 数値リテラル | 例        |
| ----------- | -------- |
| 10 進数      | `98_222` |
| 16 進数      | `0xff`   |
| 8 進数       | `0o77`   |
| 2 進数       | `0b1111_0000` |
| バイト (`u8` のみ) | `b'A'` |

* それで、どの整数型を使うかを知るにはどうすればよいか？
  * もし定かではないなら、一般的に Rust のデフォルトがよい選択になる
  * 整数型のデフォルトは `i32`
    * 64-bit のシステムでさえ、この型は一般的に最速
  * `isize` や `usize` を使う主要な状況は、何らかのコレクションをインデックス付けする時

##### 整数のオーバーフロー

* `u8` があって、それは `0` から `255` までの値を保持できるとしよう
* もしそれを `256` に変更しようとするとどうなる？
* これは「整数オーバーフロー」と呼ばれ、Rust はこの振る舞いに関していくつかの興味深いルールを持っている
  * デバッグモードでコンパイルしているとき、Rust はこの種の問題をチェックし、プログラムの _panic_ を引き起こすだろう
    * _panic_ は、プログラムがエラーで終了するときに Rust が使う用語
    * _panic_ については 9 章でもっと話す
  * リリースビルドでは、Rust はオーバーフローをチェックせず、代わりに「2 の補数ラッピング」と呼ばれることを行う
    * かいつまんで言うと、`256` は `0` になり、`257` は `1` になる
  * たとえその挙動が起こるのだとしても、オーバーフローを頼りにするのはエラーだと考えられる
    * もしこの挙動を明示的に欲しいなら、それを明示的に提供する標準ライブラリーの型 `Wrapping` がある

#### 浮動小数点型

* Rust はまた、小数点を持つ浮動小数点数のための二つのプリミティブ型を持っている
  * Rust の浮動小数点型は `f32` と `f64` で、サイズはそれぞれ 32 ビットと 64 ビット
  * デフォルトの型は `f64`
    * なぜなら、今どきの CPU は `f32` と同じくらいのスピードが出て、より精度が高いため
* 以下は実際に浮動小数点数を示す例

ファイル名: src/main.rs

```rust
fn main() {
  let x = 2.0; // f64

  let y: f32 = 3.0; // f32
}
```

* 浮動小数点数は IEEE-754 標準によって表現される
* `f32` は単精度、`f64` は倍精度

#### 数値演算

* Rust は、あなたがすべての数値型に期待する基本的な数学的演算をサポートする
  * 加算
  * 減算
  * 乗算
  * 除算
  * 剰余
* 以下のコードは、`let` ステートメントでそれぞれの演算をどのように使えるかを示している

ファイル名: src/main.rs

```rust
fn main() {
  // 加算
  let sum = 5 + 10;

  // 減算
  let difference = 95.5 - 4.3;

  // 乗算
  let product = 4 * 30;

  // 除算
  let quotient = 56.7 / 32.2;

  // 剰余
  let remainder = 43 % 5;
}
```

* これらのステートメント中のそれぞれの式は数学的演算子を使っていて、変数に束縛される単一の値を算出する
* 付録 B は Rust が提供する全ての演算子のリストを含んでいる

#### ブーリアン型

* 他のほとんどのプログラミング言語のように、Rust のブーリアン型は二つの値を取りうる
  * `true`
  * `false`
* Rust のブーリアン型は `bool` を使って指定する
* 例えば以下のようになる

ファイル名: src/main.rs

```rust
fn main() {
  let t = true;

  let f: bool = false; // 明示的な型注釈
}
```

* ブーリアン値の主な使い道は、`if` 式のような条件分岐
* 「制御フロー」の節で Rust の `if` 式がどのように動くかを網羅する
* ブーリアンのサイズは 1 バイト

#### 文字型

* ここまで数値だけを扱ってきたが、 Rust は文字もサポートする
* Rust の `char` 型は言語の最も原始的なアルファベットの型で、以下のコードは使い方の一つを示している
  * 以下のことを覚えておくこと
    * `char` リテラルは `'` で指定される
    * 対して、文字列リテラルは `"` を使う

ファイル名: src/main.rs

```rust
fn main() {
  let c = 'z';
  let z = 'ℤ';
  let heart_eyed_cat = '😻';
}
```

* Rust の `char` 型はユニコードスカラー値を表現する
  * それは、ASCII よりもとても多くの文字を表現できることを意味する
  * 以下のすべての文字が Rust で有効
    * アクセントされた文字
    * 中国語
    * 日本語
    * 韓国語
    * ゼロ幅スペース
  * ユニコードスカラー値は `U+0000` 以上 `U+D7FF` 以下、`U+E000` 以上 `U+10FFFF` 以下
  * しかしながら「文字」は本当のところユニコードの概念ではない
    * なので、「文字」が何なのかという人間の直感は、Rust の `char` が何なのかということと噛み合わないかもしれない
    * このことについて、8 章の「文字列」で詳しく議論する
